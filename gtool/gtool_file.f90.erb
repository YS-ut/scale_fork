% # -*- f90 -*-
% # vi: set sw=4 ts=8:
!-------------------------------------------------------------------------------
!> module GTOOL_FILE
!!
!! @par Description
!!          unified hundring of various kinds of files
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-12 (S.Nishizawa) [new] Imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_file
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use gtool_file_h
  use dc_log, only: &
       Log, &
       LOG_LMSG
  use dc_types, only: &
       DP, &
       SP
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FileOpen
  public :: FileCreate
  public :: FileSetOption
  public :: FileDefAxis
  public :: FilePutAxis
  public :: FileWriteAxis
  public :: FileDefAssociatedCoordinates
  public :: FilePutAssociatedCoordinates
  public :: FileWriteAssociatedCoordinates
  public :: FileAddVariable
  public :: FileDefineVariable
  public :: FileGetShape
  public :: FileGetCommoninfo
  public :: FileGetDatainfo
  public :: FileGetAllDatainfo
  public :: FileRead
  public :: FileWrite
  public :: FileGetGlobalAttribute
  public :: FileSetGlobalAttribute
  public :: FileGetAttribute
  public :: FileSetAttribute
  public :: FileAddAssociatedVariable
  public :: FileEndDef
  public :: FileFlush
  public :: FileClose
  public :: FileCloseAll
  public :: FileMakeFname
  public :: FileAttachBuffer
  public :: FileDetachBuffer

  interface FileGetCommoninfo
     module procedure FileGetCommoninfoFId
     module procedure FileGetCommoninfoFName
  end interface FileGetCommoninfo

  interface FileGetDatainfo
     module procedure FileGetDatainfoFId
     module procedure FileGetDatainfoFName
  end interface FileGetDatainfo

  interface FileGetAllDatainfo
     module procedure FileGetAllDatainfoFId
     module procedure FileGetAllDatainfoFName
  end interface FileGetAllDatainfo

  interface FilePutAxis
     module procedure FilePutAxisRealSP
     module procedure FilePutAxisRealDP
  end interface FilePutAxis
  interface FileWriteAxis
     module procedure FileWriteAxisRealSP
     module procedure FileWriteAxisRealDP
  end interface FileWriteAxis
  interface FilePutAssociatedCoordinates
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FilePut<%=n%>DAssociatedCoordinatesReal<%=rp%>
%   end
% end
  end interface FilePutAssociatedCoordinates
  interface FileWriteAssociatedCoordinates
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileWrite<%=n%>DAssociatedCoordinatesReal<%=rp%>
%   end
% end
  end interface FileWriteAssociatedCoordinates
  interface FileAddVariable
     module procedure FileAddVariableNoT
     module procedure FileAddVariableRealSP
     module procedure FileAddVariableRealDP
  end interface FileAddVariable
  interface FileRead
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileRead<%=n%>DReal<%=rp%>
%   end
% end
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileReadVar<%=n%>DReal<%=rp%>
%   end
% end
  end interface FileRead
  interface FileWrite
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileWrite<%=n%>DReal<%=rp%>
%   end
% end
  end interface FileWrite
  interface FileGetGlobalAttribute
     module procedure FileGetGlobalAttributeText
     module procedure FileGetGlobalAttributeInt
     module procedure FileGetGlobalAttributeFloat
     module procedure FileGetGlobalAttributeDouble
  end interface FileGetGlobalAttribute
  interface FileSetGlobalAttribute
     module procedure FileSetGlobalAttributeText
     module procedure FileSetGlobalAttributeInt
     module procedure FileSetGlobalAttributeFloat
     module procedure FileSetGlobalAttributeDouble
  end interface FileSetGlobalAttribute
  interface FileGetAttribute
     module procedure FileGetAttributeText
     module procedure FileGetAttributeInt
     module procedure FileGetAttributeFloat
     module procedure FileGetAttributeDouble
  end interface FileGetAttribute
  interface FileSetAttribute
     module procedure FileSetAttributeText
     module procedure FileSetAttributeInt
     module procedure FileSetAttributeFloat
     module procedure FileSetAttributeDouble
  end interface FileSetAttribute

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  real(DP), parameter, public :: RMISS = -9.9999e+30
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  integer,                   private, parameter :: File_nfile_max = 512   ! number limit of file
                                                 ! Keep consistency with "FILE_MAX" in gtool_netcdf.c
  integer,                   private, parameter :: File_nvar_max  = 40960 ! number limit of variables
                                                 ! Keep consistency with "VAR_MAX" in gtool_netcdf.c

  character(len=File_HLONG), private,      save :: File_fname_list(File_nfile_max)
  integer,                   private,      save :: File_fid_list  (File_nfile_max)
  integer,                   private,      save :: File_fid_count = 1
  character(len=File_HLONG), private,      save :: File_vname_list  (File_nvar_max)
  integer,                   private,      save :: File_vid_fid_list(File_nvar_max)
  integer,                   private,      save :: File_vid_list    (File_nvar_max)
  integer,                   private,      save :: File_vid_count = 1
  integer,                   private,      save :: mpi_myrank

  character(len=LOG_LMSG),   private            :: message

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  subroutine FileCreate( &
       fid,         &
       existed,     &
       basename,    &
       title,       &
       source,      &
       institution, &
       master,      &
       myrank,      &
       single,      &
       time_units,  &
       append,      &
       comm         )
    use mpi, only: &
       MPI_COMM_NULL
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: title
    character(len=*), intent(in)  :: source
    character(len=*), intent(in)  :: institution
    integer,          intent(in)  :: master
    integer,          intent(in)  :: myrank

    logical,          intent(in), optional :: single
    character(len=*), intent(in), optional :: time_units
    logical,          intent(in), optional :: append
    integer,          intent(in), optional :: comm       ! MPI communicator

    character(len=File_HMID) :: time_units_
    logical :: single_
    integer :: mode

    integer :: error
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    single_ = .false.
    if ( present(single) ) then
       if( single .AND. myrank /= master ) return ! do nothing
       single_ = single
    endif

    if ( present(time_units) ) then
       time_units_ = time_units
    else
       time_units_ = 'seconds'
    endif

    mode = File_FWRITE
    if ( present(append) ) then
       if( append ) mode = File_FAPPEND
    endif

    call FileGetfid( fid,      & ! [OUT]
                     existed,  & ! [OUT]
                     basename, & ! [IN]
                     mode,     & ! [IN]
                     single_,  & ! [IN]
                     comm      ) ! [IN]

    if( existed ) return

    !--- append package header to the file
    call FileSetGlobalAttribute( fid, "title"      , title       ) ! [IN]
    call FileSetGlobalAttribute( fid, "source"     , source      ) ! [IN]
    call FileSetGlobalAttribute( fid, "institution", institution ) ! [IN]

    if ( .NOT. present(comm) .OR. comm == MPI_COMM_NULL ) then
       ! for shared-file parallel I/O, skip attributes related to MPI processes
       call FileSetGlobalAttribute( fid, "myrank"  , (/myrank/)  ) ! [IN]
    endif

    call file_set_tunits( fid,         & ! [IN]
                          time_units_, & ! [IN]
                          error        ) ! [OUT]

    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set time units')
    endif

    return
  end subroutine FileCreate

  !-----------------------------------------------------------------------------
  subroutine FileGetVarnum( &
       fid,         &
       nvars_limit, &
       nvars        )
    implicit none

    integer, intent(in)  :: fid
    integer, intent(in)  :: nvars_limit
    integer, intent(out) :: nvars

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_nvars( fid,         & ! (in)
                         nvars, error ) ! (out)

    if ( error /= SUCCESS_CODE ) then
       write(message,*) 'xxx [FileGetVarnum] failed to get varnum. fid = ', fid
       call Log('E', message)
    end if

    if ( nvars > nvars_limit ) then
       write(message,*) 'xxx [FileGetCommoninfo] number of variables exceeds the requested size.', nvars, nvars_limit
       call Log('E', message)
    endif

    return
  end subroutine FileGetVarnum

  !-----------------------------------------------------------------------------
  subroutine FileGetVarname( &
       fid,    &
       vid,    &
       varname )
    implicit none

    integer,          intent(in)  :: fid
    integer,          intent(in)  :: vid
    character(len=*), intent(out) :: varname

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_varname( fid, vid,      & ! (in)
                           varname, error ) ! (out)

    if ( error /= SUCCESS_CODE ) then
       write(message,*) 'xxx [FileGetVarname] failed to get varname. vid = ', vid
       call Log('E', message)
    end if

    return
  end subroutine FileGetVarname

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    character(len=*), intent(out) :: val

    integer error

    intrinsic size

    call file_get_global_attribute_text( & ! (in)
         fid, key,                       & ! (in)
         val, error                      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get text global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    integer,          intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_int( & ! (in)
         fid, key, size(val),           & ! (in)
         val, error                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeInt

% [["SP","Float"], ["DP","Double"]].each do |rp,name|
  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttribute<%=name%>( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(<%=rp%>),    intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_<%=name.downcase%>( & ! (in)
         fid, key, size(val),                          & ! (in)
         val, error                                    ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get <%=name.downcase%> global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttribute<%=name%>

% end

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer error

    call file_set_global_attribute_text( fid, & ! (in)
         key, val,                            & ! (in)
         error                                ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set text global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_int( fid, & ! (in)
         key, val, size(val),                & ! (in)
         error                               ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeInt

% [["SP","Float"], ["DP","Double"]].each do |rp,name|
  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttribute<%=name%>( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(<%=rp%>),    intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_<%=name.downcase%>( fid, & ! (in)
         key, val, size(val),                               & ! (in)
         error                                              ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set <%=name.downcase%> global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttribute<%=name%>

% end
  !-----------------------------------------------------------------------------
  subroutine FileAddAssociatedVariable( fid, vname, existed )
    integer,           intent(in)  :: fid
    character(len=*),  intent(in)  :: vname
    logical, optional, intent(out) :: existed

    integer error

    call file_add_associated_variable( fid, vname , & ! (in)
                                       error        ) ! (out)

    if ( present(existed) ) then
       if ( error == ALREADY_EXISTED_CODE ) then
          existed = .true.
          return
       end if
       existed = .false.
    end if

    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to add associated variable: '//trim(vname))
    end if

    return
  end subroutine FileAddAssociatedVariable

  !-----------------------------------------------------------------------------
  subroutine FileSetOption( &
       fid,      & ! (in)
       filetype, & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: filetype
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer error

    call file_set_option( fid, filetype, key, val, & ! (in)
                          error                    ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set option')
    end if

    return
  end subroutine FileSetOption

  !-----------------------------------------------------------------------------
  subroutine FileOpen( &
      fid,       & ! (out)
      basename,  & ! (in)
      mode,      & ! (in)
      single,    & ! (in) optional
      comm,      & ! (in) optional
      myrank     & ! (in) optional
      )
    implicit none

    integer,          intent(out) :: fid
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: comm
    integer,          intent( in), optional :: myrank

    logical :: existed
    logical :: single_

    single_ = .false.

    if ( present(single) ) single_ = single
    if ( present(myrank) ) mpi_myrank = myrank

    call FileGetfid( fid, existed,     & ! (out)
         basename, mode, single_, comm ) ! (in)

    return
  end subroutine FileOpen

  !-----------------------------------------------------------------------------
  ! interface FilePutAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine FilePutAxisReal<%=rp%>( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(<%=rp%>),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_axis( fid, name, desc, units, dim_name, dtype, val, size(val), <%=rp%>, & ! (in)
         error                                                                            ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FilePutAxisReal<%=rp%>
%end

  subroutine FileDefAxis( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       dim_size  ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    integer,          intent(in) :: dim_size

    integer error
    intrinsic size

    call file_def_axis( fid, name, desc, units, dim_name, dtype, dim_size, & ! (in)
         error                                                             ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to define axis')
    end if

    return
  end subroutine FileDefAxis

  !-----------------------------------------------------------------------------
  ! interface FileWriteAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine FileWriteAxisReal<%=rp%>( &
       fid,      & ! (in)
       name,     & ! (in)
       val,      & ! (in)
       start     ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(<%=rp%>),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis( fid, name, val, <%=rp%>, start, shape(val), & ! (in)
            error                                                        ) ! (out)
    else
       call file_write_axis( fid, name, val, <%=rp%>, (/1/), shape(val), & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to write axis: '//trim(name))
    end if

    return
  end subroutine FileWriteAxisReal<%=rp%>
%end

  !-----------------------------------------------------------------------------
  ! interface FilePutAssociatedCoordinates
  !-----------------------------------------------------------------------------
% for n in 1..4
%   ["SP", "DP"].each do |rp|
  subroutine FilePut<%=n%>DAssociatedCoordinatesReal<%=rp%>( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(<%=rp%>),    intent(in) :: val(<%=Array.new(n){":"}.join(",")%>)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, <%=rp%>,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FilePut<%=n%>DAssociatedCoordinatesReal<%=rp%>
%  end
% end

  subroutine FileDefAssociatedCoordinates( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype      ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype

    integer error
    intrinsic size

    call file_def_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileDefAssociatedCoordinates

  !-----------------------------------------------------------------------------
  ! interface FileWriteAssociatedCoordinates
  !-----------------------------------------------------------------------------
% for n in 1..4
%   ["SP", "DP"].each do |rp|
  subroutine FileWrite<%=n%>DAssociatedCoordinatesReal<%=rp%>( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(<%=rp%>),    intent(in)           :: val(<%=Array.new(n){":"}.join(",")%>)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, <%=rp%>, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, <%=rp%>, & ! (in)
            <%=n%>, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, <%=rp%>, & ! (in)
            <%=n%>, (/<%=([1]*n).join(",")%>/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite<%=n%>DAssociatedCoordinatesReal<%=rp%>
%  end
% end

  !-----------------------------------------------------------------------------
  ! interface FileAddVariable
  !-----------------------------------------------------------------------------
  subroutine FileAddVariableNoT( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    logical,          intent( in), optional :: tavg

    call FileAddVariableRealDP(vid, fid, varname, desc, units, dims, dtype, -1.0_DP, tavg )

    return
  end subroutine FileAddVariableNoT

% ["SP", "DP"].each do |rp|
  !-----------------------------------------------------------------------------
  subroutine FileAddVariableReal<%=rp%>( &
       vid,     &
       fid,     &
       varname, &
       desc,    &
       units,   &
       dims,    &
       dtype,   &
       tint,    &
       tavg     )
    implicit none

    integer,          intent(out) :: vid
    integer,          intent(in)  :: fid
    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    character(len=*), intent(in)  :: dims(:)
    integer,          intent(in)  :: dtype
    real(<%=rp%>),    intent(in)  :: tint

    logical,          intent(in), optional :: tavg

    real(DP) :: tint8
    integer  :: ndims
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if (       File_vid_fid_list(n) == fid     &
            .AND. File_vname_list  (n) == varname ) then
          vid = File_vid_list(n)
          exit
       endif
    enddo

    if ( vid < 0 ) then ! variable registration

       tint8 = real(tint,DP)
       ndims = size(dims)
       itavg = 0

       if ( present(tavg) ) then
          if( tavg ) itavg = 1
       endif

       call file_add_variable( vid,                                                         & ! [OUT]
                               fid, varname, desc, units, dims, ndims, dtype, tint8, itavg, & ! [IN]
                               error                                                        ) ! [OUT]

       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       endif

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1

       write(message,'(A,I3.3,A,I4.4,2A)') &
       '###### File variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
       call Log("I",message)
    endif

    return
  end subroutine FileAddVariableReal<%=rp%>

%end
  subroutine FileDefineVariable( &
       fid,     & ! (in)
       vid,     & ! (out)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       ndims,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in) optional
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: ndims
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(DP),         intent( in), optional :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint_
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration

       if ( present(tint) ) then
          tint_ = tint
       else
          tint_ = -1.0_DP
       endif

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                        & ! (out)
            fid, varname, desc, units, dims, ndims, dtype, & ! (in)
            tint_, itavg,                                  & ! (in)
            error                                          ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1

       write(message,'(A,I3.3,A,I4.4,2A)') &
       '###### File variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
       call Log("I",message)
    endif

    return
  end subroutine FileDefineVariable

  !-----------------------------------------------------------------------------
  ! FileGetAttribute
  !-----------------------------------------------------------------------------
  subroutine FileGetAttributeText( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    character(len=*), intent(out) :: val

    integer :: error

    call file_get_attribute_text( &
         fid, vname, & ! (in)
         key,        & ! (in)
         val, error  ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get text attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FileGetAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileGetAttributeInt( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    integer,          intent(out) :: val(:)

    integer :: error

    intrinsic size

    call file_get_attribute_int( &
         fid, vname,     & ! (in)
         key, size(val), & ! (in)
         val, error      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get integer attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FileGetAttributeInt
  !-----------------------------------------------------------------------------

% [["SP","Float"], ["DP","Double"]].each do |rp,name|
  subroutine FileGetAttribute<%=name%>( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    real(<%=rp%>),    intent(out) :: val(:)

    integer :: error

    intrinsic size

    call file_get_attribute_<%=name.downcase%>( &
         fid, vname,     & ! (in)
         key, size(val), & ! (in)
         val, error      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get <%=name.downcase%> attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FileGetAttribute<%=name%>
%end

  !-----------------------------------------------------------------------------
  ! FileSetAttribute
  !-----------------------------------------------------------------------------
  subroutine FileSetAttributeText( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_attribute_text( &
         fid, vname, & ! (in)
         key, val,   & ! (in)
         error       ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set text attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FileSetAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileSetAttributeInt( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: error

    intrinsic :: size

    call file_set_attribute_int( &
         fid, vname,                & ! (in)
         key, val(:), size(val(:)), & ! (in)
         error                      ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set integer attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FileSetAttributeInt

% [["SP","Float"], ["DP","Double"]].each do |rp,name|
  !-----------------------------------------------------------------------------
  subroutine FileSetAttribute<%=name%>( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    real(<%=rp%>),    intent(in) :: val(:)

    integer :: error

    intrinsic :: size

    call file_set_attribute_<%=name.downcase%>( &
         fid, vname,                & ! (in)
         key, val(:), size(val(:)), & ! (in)
         error                      ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set <%=name.downcase%> attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FileSetAttribute<%=name%>
%end
  !-----------------------------------------------------------------------------
  ! FileGetShape
  !-----------------------------------------------------------------------------
  subroutine FileGetShape( &
      dims,          & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      myrank,        & ! (in)
      single,        & ! (in) optional
      error          ) ! (out) optional
    implicit none

    integer,          intent(out)           :: dims(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: single
    logical,          intent(out), optional :: error

    integer :: fid
    type(datainfo) :: dinfo
    integer :: ierror
    integer :: n

    logical :: single_
    logical :: suppress

    intrinsic size
    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    end if

    if ( present(error) ) then
       suppress = .true.
    else
       suppress = .false.
    end if

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,  & ! (out)
         fid, varname, 1, suppress, & ! (in)
         ierror                     ) ! (out)

    !--- verify
    if ( ierror /= SUCCESS_CODE ) then
       if ( present(error) ) then
          error = .true.
          return
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= size(dims) ) then
       write(message,*) 'xxx rank is different, ', size(dims), dinfo%rank
       call Log('E', message)
    end if
    do n = 1, size(dims)
       dims(n) = dinfo%dim_size(n)
    end do

    if ( present(error) ) error = .false.

    return
  end subroutine FileGetShape

  !-----------------------------------------------------------------------------
  ! FileGetCommoninfo
  !-----------------------------------------------------------------------------
  subroutine FileGetCommoninfoFName( &
       basename,    &
       myrank,      &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       nvars,       &
       varname      )
    implicit none

    character(len=*),           intent(in)  :: basename
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: nvars_limit
    character(len=File_HMID),   intent(out) :: title                ! title of the file
    character(len=File_HMID),   intent(out) :: source               ! for file header
    character(len=File_HMID),   intent(out) :: institution          ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=File_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: fid
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    call FileOpen( fid,       & ! [OUT]
                   basename,  & ! [IN]
                   File_FREAD ) ! [IN]

    call FileGetCommoninfoFId( fid,         & ! [IN]
                               myrank,      & ! [IN]
                               nvars_limit, & ! [IN]
                               title,       & ! [OUT]
                               source,      & ! [OUT]
                               institution, & ! [OUT]
                               nvars,       & ! [OUT]
                               varname(:)   ) ! [OUT]

    return
  end subroutine FileGetCommoninfoFName

  subroutine FileGetCommoninfoFId( &
       fid,         &
       myrank,      &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       nvars,       &
       varname      )
    implicit none

    integer,                    intent(in)  :: fid
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: nvars_limit
    character(len=File_HMID),   intent(out) :: title                ! title of the file
    character(len=File_HMID),   intent(out) :: source               ! for file header
    character(len=File_HMID),   intent(out) :: institution          ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=File_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: myrank_check(1)
    integer :: v
    !---------------------------------------------------------------------------

    call FileGetGlobalAttribute( fid, 'title',       title       )
    call FileGetGlobalAttribute( fid, 'source',      source      )
    call FileGetGlobalAttribute( fid, 'institution', institution )
    call FileGetGlobalAttribute( fid, 'myrank',      myrank_check(:) )

    if ( myrank /= myrank_check(1) ) then
       call Log('E','xxx [FileGetCommoninfo] requested rank number is inconsistent with that in the file.')
    endif

    call FileGetVarnum( fid, nvars_limit, nvars )

    do v = 1, nvars
       call FileGetVarname( fid, v, varname(v) )
    enddo

    return
  end subroutine FileGetCommoninfoFId

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetDatainfoFName( &
       basename,    &
       varname,     &
       myrank,      &
       istep,       &
       single,      &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: istep

    logical,                    intent(in),  optional :: single
    character(len=File_HMID),   intent(out), optional :: description
    character(len=File_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=File_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=File_HMID),   intent(out), optional :: time_units

    logical :: single_
    integer :: fid
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    call FileGetDatainfoFId( fid,         & ! [IN]
                             varname,     & ! [IN]
                             istep,       & ! [IN]
                             description, & ! [OUT], optional
                             units,       & ! [OUT], optional
                             datatype,    & ! [OUT], optional
                             dim_rank,    & ! [OUT], optional
                             dim_name,    & ! [OUT], optional
                             dim_size,    & ! [OUT], optional
                             time_start,  & ! [OUT], optional
                             time_end,    & ! [OUT], optional
                             time_units   ) ! [OUT], optional

    return
  end subroutine FileGetDatainfoFName

  subroutine FileGetDatainfoFId( &
       fid,         &
       varname,     &
       istep,       &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: istep

    character(len=File_HMID),   intent(out), optional :: description
    character(len=File_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=File_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=File_HMID),   intent(out), optional :: time_units

    type(datainfo) :: dinfo

    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    intrinsic size
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,   & ! [OUT]
                            fid,     & ! [IN]
                            varname, & ! [IN]
                            istep,   & ! [IN]
                            .false., & ! [IN]
                            error    ) ! [OUT]

    !--- verify and exit
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx data info not found')
    endif

    if( present(description) ) description = dinfo%description
    if( present(units)       ) units       = dinfo%units
    if( present(datatype)    ) datatype    = dinfo%datatype
    if( present(dim_rank)    ) dim_rank    = dinfo%rank

    if ( present(dim_name) ) then
       ndim = min( dinfo%rank, size(dim_name) ) ! limit dimension rank
       do idim = 1, ndim
          dim_name(idim) = dinfo%dim_name(idim)
       enddo
    endif

    if ( present(dim_size) ) then
       ndim = min( dinfo%rank, size(dim_size) ) ! limit dimension rank
       do idim = 1, ndim
          dim_size(idim) = dinfo%dim_size(idim)
       enddo
    endif

    if ( present(time_units)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time_units", time_units )
       else
          time_units = dinfo%time_units
       endif
    endif

    if ( present(time_start)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time_start", time )
          time_start = time(1)
       else
          time_start = dinfo%time_start
       endif
    endif

    if ( present(time_end)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time_start", time )
          time_end = time(1)
       else
          time_end = dinfo%time_end
       end if
    endif

    return
  end subroutine FileGetDatainfoFId

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetAllDatainfoFName( &
       step_limit,  &
       dim_limit,   &
       basename,    &
       varname,     &
       myrank,      &
       step_nmax,   &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units,  &
       single       )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(out) :: step_nmax
    character(len=File_HMID),   intent(out) :: description
    character(len=File_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=File_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=File_HMID),   intent(out) :: time_units

    logical,                    intent(in), optional :: single

    integer :: fid
    logical :: single_
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    call FileGetAllDatainfoFId( step_limit,  & ! [IN]
                                dim_limit,   & ! [IN]
                                fid,         & ! [IN]
                                varname,     & ! [IN]
                                step_nmax,   & ! [OUT]
                                description, & ! [OUT]
                                units,       & ! [OUT]
                                datatype,    & ! [OUT]
                                dim_rank,    & ! [OUT]
                                dim_name,    & ! [OUT]
                                dim_size,    & ! [OUT]
                                time_start,  & ! [OUT]
                                time_end,    & ! [OUT]
                                time_units   ) ! [OUT]

    return
  end subroutine FileGetAllDatainfoFName

  subroutine FileGetAllDatainfoFId( &
       step_limit,  &
       dim_limit,   &
       fid,         &
       varname,     &
       step_nmax,   &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(out) :: step_nmax
    character(len=File_HMID),   intent(out) :: description
    character(len=File_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=File_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=File_HMID),   intent(out) :: time_units

    type(datainfo) :: dinfo

    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    integer  :: istep
    !---------------------------------------------------------------------------

    ! initialize
    description   = ""
    units         = ""
    datatype      = -1
    dim_rank      = -1
    dim_name  (:) = ""
    dim_size  (:) = -1
    time_start(:) = RMISS
    time_end  (:) = RMISS

    do istep = 1, step_limit
       !--- get data information
       call file_get_datainfo( dinfo,   & ! [OUT]
                               fid,     & ! [IN]
                               varname, & ! [IN]
                               istep,   & ! [IN]
                               .true.,  & ! [IN]
                               error    ) ! [OUT]

       !--- verify and exit
       if ( error /= SUCCESS_CODE ) then
          step_nmax = istep - 1
          exit
       endif

       if ( istep == 1 ) then
          description = dinfo%description
          units       = dinfo%units
          datatype    = dinfo%datatype
          dim_rank    = dinfo%rank

          ndim = min( dinfo%rank, dim_limit ) ! limit dimension rank
          do idim = 1, ndim
             dim_name(idim) = dinfo%dim_name(idim)
             dim_size(idim) = dinfo%dim_size(idim)
          enddo

          if ( dinfo%time_units == "" ) then
             call FileGetGlobalAttribute( fid, "time_units", time_units )
             call FileGetGlobalAttribute( fid, "time_start", time )
             time_start(1) = time(1)
             time_end  (1) = time(1)
             step_nmax = 1
             exit
          else
             time_units    = dinfo%time_units
             time_start(1) = dinfo%time_start
             time_end  (1) = dinfo%time_end
          endif
       else
          time_start(istep) = dinfo%time_start
          time_end  (istep) = dinfo%time_end
       endif
    enddo

    return
  end subroutine FileGetAllDatainfoFId

  !-----------------------------------------------------------------------------
  ! interface File_read
  !-----------------------------------------------------------------------------
% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FileRead<%=d%>DReal<%=rp%>( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(<%=rp%>),    intent(out)           :: var(<%=idx%>)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(<%=d%>)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(<%=idx%>) = 0.0_<%=rp%>
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= <%=d%> ) then
       write(message,*) 'xxx rank is not <%=d%>', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, <%=d%>
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(<%=idx%>), & ! (out)
         dinfo, <%=rp%>,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead<%=d%>DReal<%=rp%>
%   end
% end

% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FileReadVar<%=d%>DReal<%=rp%>( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(<%=rp%>),    intent(out)           :: var(<%=idx%>)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(<%=d%>)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(<%=idx%>) = 0.0_<%=rp%>
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= <%=d%> ) then
       write(message,*) 'xxx rank is not <%=d%>', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(<%=idx%>),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, <%=d%>
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data( var(<%=idx%>), & ! (out)
            dinfo, <%=rp%>,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar<%=d%>DReal<%=rp%>
%   end
% end

  !-----------------------------------------------------------------------------
  ! interface FileWrite
  !-----------------------------------------------------------------------------
% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FileWrite<%=d%>DReal<%=rp%>( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(<%=rp%>), intent(in) :: var(<%=idx%>)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(<%=d%>)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(<%=idx%>), ts, te, <%=rp%>, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(<%=idx%>), ts, te, <%=rp%>, & ! (in)
            <%=d%>, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite<%=d%>DReal<%=rp%>
%   end
% end

  !-----------------------------------------------------------------------------
  ! exit netCDF define mode and enter data mode
  subroutine FileEndDef( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileEndDef invalid fid' , fid
       call Log('E', message)
    end if

    call file_enddef( fid, error )

    if ( error == SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### File end define mode       : No.', File_fid_list(n), ', name = ', trim(File_fname_list(n))
       call Log("I",message)

    else

       call Log('E', 'xxx failed to exit define mode')

    end if

    return
  end subroutine FileEndDef

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileAttachBuffer( &
       fid,       & ! (in)
       buf_amount ) ! (in)
    implicit none

    integer, intent(in) :: fid
    integer, intent(in) :: buf_amount

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileAttachBuffer invalid fid' , fid
       call Log('E', message)
    end if

    call file_attach_buffer( fid, buf_amount, error )

    if ( error == SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,3A,I10)') &
       '###### File attach buffer         : No.', File_fid_list(n), ', name = ', trim(File_fname_list(n)), &
                                                                    ', size = ', buf_amount
       call Log("I",message)

    else

       call Log('E', 'xxx failed to attach buffer in PnetCDF')

    end if

    return
  end subroutine FileAttachBuffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileDetachBuffer( &
       fid        ) ! (in)
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n == File_fid_count ) return  ! already closed

    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileDetachBuffer invalid fid' , fid
       call Log('E', message)
    end if

    call file_detach_buffer( fid, error )

    if ( error == SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### File detach buffer         : No.', File_fid_list(n), ', name = ', trim(File_fname_list(n))
       call Log("I",message)

    else

       call Log('E', 'xxx failed to detach buffer in PnetCDF')

    end if

    return
  end subroutine FileDetachBuffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileFlush( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return
    if ( File_fid_count == 1 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n == File_fid_count ) return  ! already closed

    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileFlush invalid fid' , fid
       call Log('E', message)
    end if

    call file_flush( fid, error )

    if ( error == SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### File flush                 : No.', File_fid_list(n), ', name = ', trim(File_fname_list(n))
       call Log("I",message)

    else

       call Log('E', 'xxx failed to flush PnetCDF pending requests')

    end if

    return
  end subroutine FileFlush

  !-----------------------------------------------------------------------------
  subroutine FileClose( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    character(len=File_HLONG) :: fname
    integer                   :: error
    integer                   :: n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n == File_fid_count ) return  ! already closed

    if ( fid /= File_fid_list(n) ) then
       write(message,*) 'xxx in FileClose invalid fid ', fid
       call Log('E', message)
    end if

    call file_close( fid, error )

    if ( error == SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### File close                 : No.', File_fid_list(n), ', name = ', trim(File_fname_list(n))
       call Log("I",message)

    elseif( error /= ALREADY_CLOSED_CODE ) then

       call Log('E', 'xxx failed to close file')

    end if

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) then
          File_fid_list(n) = -1
          File_fname_list(n) = ''
       end if
    end do

    return
  end subroutine FileClose
  !-----------------------------------------------------------------------------
  subroutine FileCloseAll
    implicit none

    integer n
    !---------------------------------------------------------------------------

    do n = 1, File_fid_count-1
       call FileClose( File_fid_list(n) )
    enddo

    return
  end subroutine FileCloseAll

  !-----------------------------------------------------------------------------
  ! private
  !-----------------------------------------------------------------------------
  subroutine FileMakeFname( &
       fname,    & ! (out)
       basename, & ! (in)
       prefix,   & ! (in)
       myrank,   & ! (in)
       len       ) ! (in)
    character(len=*), intent(out) :: fname
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: prefix
    integer,          intent( in) :: myrank
    integer,          intent( in) :: len

    !                           12345678901234567
    character(len=17) :: fmt = "(A, '.', A, I*.*)"
    !---------------------------------------------------------------------------

    if ( len < 1 .or. len > 9 ) then
       call Log('E', 'xxx len is invalid')
    end if

    write(fmt(14:14),'(I1)') len
    write(fmt(16:16),'(I1)') len
    write(fname, fmt) trim(basename), trim(prefix), myrank

    return
  end subroutine FileMakeFname
  !-----------------------------------------------------------------------------
  subroutine FileGetfid( &
      fid,        &
      existed,    &
      basename,   &
      mode,       &
      single,     &
      comm        )
    use MPI, only : MPI_COMM_NULL, MPI_COMM_SELF
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in) :: single
    integer,          intent( in), optional :: comm

    character(len=File_HSHORT) :: rwname(0:2)
    data rwname / 'READ','WRITE','APPEND' /

    character(len=File_HLONG) :: fname
    integer                   :: n

    integer :: error
    integer :: comm_
    !---------------------------------------------------------------------------

    !--- register new file and open
    comm_ = MPI_COMM_NULL
    if ( present(comm) ) comm_ = comm
    if ( comm_ .NE. MPI_COMM_NULL ) then
       ! parallel I/O on a single shared netCDF file
       fname = basename
       comm_ = comm
    elseif ( single ) then
       fname = trim(basename)//'.peall'
    else
       call FileMakeFname(fname,trim(basename),'pe',mpi_myrank,6)
    endif

    !--- search existing file
    fid = -1
    do n = 1, File_fid_count-1
       if ( fname==File_fname_list(n) ) fid = File_fid_list(n)
    enddo

    if ( fid >= 0 ) then
       existed = .true.
       return
    end if

    call file_open( fid,     & ! (out)
         fname, mode, comm_, & ! (in)
         error               ) ! (out)

    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to open file :'//trim(fname)//'.nc')
    end if

    call Log("I",'')
    write(message,'(A,A6,A,I3.3,2A)') &
    '###### File registration (', trim(rwname(mode)), ') : No.', fid, ', name = ', trim(fname)
    call Log("I",message)

    File_fname_list(File_fid_count) = trim(fname)
    File_fid_list  (File_fid_count) = fid
    File_fid_count                  = File_fid_count + 1

    existed = .false.

    return
  end subroutine FileGetfid

end module gtool_file
!-------------------------------------------------------------------------------


!--
! vi<%=":"%>set readonly sw=4 ts=8
!
!Local Variables<%=":"%>
!mode: f90
!buffer-read-only: t
!End:
!
!++
