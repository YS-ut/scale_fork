!-------------------------------------------------------------------------------
!> module Gtool_History
!!
!! @par Description
!!          module library for history output
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-11 (S.Nishizawa)  [new] imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from gtool_history.f90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_history
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
     Log,         &
     Log_nml,     &
     LOG_fid,     &
     LOG_fid_nml, &
     LOG_LMSG
  use dc_types, only: &
     SP, &
     DP
  use gtool_file_h, only: &
     File_HLONG, &
     File_HSHORT, &
     File_HMID
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: HistoryInit
  public :: HistoryCheck
  public :: HistoryAddVariable
  public :: HistoryFileCreate
  public :: HistoryPutAxis
  public :: HistoryPutAssociatedCoordinates
  public :: HistorySetGlobalAttribute
  public :: HistorySetAttribute
  public :: HistorySetMapping
  public :: HistoryQuery
  public :: HistoryPut
  public :: HistoryWriteAll
  public :: HistoryWriteAxes
  public :: HistoryWrite
  public :: HistoryGet
  public :: HistoryOutputList
  public :: HistoryFinalize

  interface HistoryPutAxis
     module procedure HistoryPutAxisSP
     module procedure HistoryPutAxisDP
  end interface HistoryPutAxis

  interface HistoryPutAssociatedCoordinates
     module procedure HistoryPut1DAssociatedCoordinatesSP
     module procedure HistoryPut1DAssociatedCoordinatesDP
     module procedure HistoryPut2DAssociatedCoordinatesSP
     module procedure HistoryPut2DAssociatedCoordinatesDP
     module procedure HistoryPut3DAssociatedCoordinatesSP
     module procedure HistoryPut3DAssociatedCoordinatesDP
     module procedure HistoryPut4DAssociatedCoordinatesSP
     module procedure HistoryPut4DAssociatedCoordinatesDP
  end interface HistoryPutAssociatedCoordinates

  interface HistorySetGlobalAttribute
     module procedure HistorySetGlobalAttributeText
     module procedure HistorySetGlobalAttributeInt
     module procedure HistorySetGlobalAttributeFloat
     module procedure HistorySetGlobalAttributeDouble
  end interface HistorySetGlobalAttribute

  interface HistorySetAttribute
     module procedure HistorySetAttributeText
     module procedure HistorySetAttributeInt
     module procedure HistorySetAttributeFloat
     module procedure HistorySetAttributeDouble
  end interface HistorySetAttribute

  interface HistoryPut
     module procedure HistoryPut0DIdSP
     module procedure HistoryPut0DIdDP
     module procedure HistoryPut1DIdSP
     module procedure HistoryPut1DIdDP
     module procedure HistoryPut2DIdSP
     module procedure HistoryPut2DIdDP
     module procedure HistoryPut3DIdSP
     module procedure HistoryPut3DIdDP
  end interface HistoryPut

  interface HistoryGet
     module procedure HistoryGet1DSP
     module procedure HistoryGet1DDP
     module procedure HistoryGet2DSP
     module procedure HistoryGet2DDP
     module procedure HistoryGet3DSP
     module procedure HistoryGet3DDP
  end interface HistoryGet

  type request
     character(len=File_HSHORT) :: item              !> Name of variable (in the code)
     character(len=File_HSHORT) :: outname           !> Name of variable (for output)
     character(len=File_HLONG)  :: basename          !> Base name of the file
     logical                    :: postfix_timelabel !> Add time label to basename?
     character(len=File_HMID)   :: zcoord            !> Z-coordinate
     integer                    :: dstep             !> Time unit
     logical                    :: taverage          !> Apply time average?
     integer                    :: dtype             !> Data type
     logical                    :: registered        !> This item is registered?
  end type request

  type vars
     character(len=File_HSHORT) :: item              !> Name of variable (in the code)
     character(len=File_HSHORT) :: outname           !> Name of variable (for output)
     character(len=File_HLONG)  :: basename          !> Base name of the file
     logical                    :: postfix_timelabel !> Add time label to basename?
     character(len=File_HMID)   :: zcoord            !> Z-coordinate
     integer                    :: dstep             !> Time unit
     logical                    :: taverage          !> Apply time average?
     integer                    :: dtype             !> Data type

     integer                    :: fid               !> File id of the file
     integer                    :: vid               !> Variable id
     character(len=File_HLONG)  :: desc              !> Variable description
     character(len=File_HSHORT) :: units             !> Variable units
     character(len=File_HSHORT) :: mapping           !> Map projection
     integer                    :: ndims             !> number of dimensions
     character(len=File_HSHORT) :: dims (4)          !> name of dimension
     integer                    :: start(4)          !> global subarray starting indices
     integer                    :: count(4)          !> global subarray request sizes

     integer                    :: waitstep          !> Step length to suppress output [step]
     integer                    :: laststep_write    !> Last step when the variable is written
     integer                    :: laststep_put      !> Last step when the variable is put
     logical                    :: flag_clear        !> Data buffer should be cleared at the timing of putting?
     integer                    :: size              !> Size of array
     real(DP)                   :: timesum           !> Buffer for time
     real(DP), pointer          :: varsum(:)         !> Buffer for value
  end type vars

  type axis
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     character(len=File_HSHORT) :: dim
     integer                    :: dtype
     integer                    :: dim_size
     real(DP), pointer          :: var(:)
     logical                    :: down
     integer                    :: gdim_size  ! global dimension size
     integer                    :: start(1)   ! global array start index
  end type axis

  type assoc
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     integer                    :: ndims
     character(len=File_HSHORT) :: dims(4)
     integer                    :: dtype
     real(DP), pointer          :: var(:)
     integer                    :: start(4)   ! global array start indices
     integer                    :: count(4)   ! global array request lengths
  end type assoc

  !-----------------------------------------------------------------------------
  !
  !++ included parameters
  !
  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !

  ! From upstream side of the library
  integer,                    private              :: History_master                    !> Number of master rank
  integer,                    private              :: History_myrank                    !> Number of my rank

  real(DP),                   private              :: History_STARTDAYSEC               !> Start date [second]
  real(DP),                   private              :: History_DTSEC                     !> Delta t    [second]
  character(len=File_HMID),   private              :: History_TIME_SINCE                !> Offset time

  ! From NAMELIST or upstream side of the library
  character(len=File_HMID),   private              :: History_TITLE                             !> Header information of the output file: title
  character(len=File_HMID),   private              :: History_SOURCE                            !> Header information of the output file: model name
  character(len=File_HMID),   private              :: History_INSTITUTION                       !> Header information of the output file: institution
  character(len=File_HMID),   private              :: History_TIME_UNITS                        !> Unit for time axis
  logical,                    private              :: History_OUTPUT_STEP0            = .false. !> Output value at step=0?
  integer,                    private              :: History_OUTPUT_WAIT_STEP                  !> Step length to suppress output
  integer,                    private              :: History_OUTPUT_SWITCH_STEP                !> Step interval to switch output file
  integer,                    private              :: History_OUTPUT_SWITCH_LASTSTEP            !> Last step when the file is switched
  logical,                    private              :: History_ERROR_PUTMISS           = .true.  !> Abort if the value is never stored after last output?

  ! working
  integer,                    private, parameter   :: History_req_limit     = 1000      !> number limit for history item request
  integer,                    private              :: History_req_count     = 0         !> number of requested item
  type(request),              private, allocatable :: History_req(:)

  integer,                    private              :: History_id_count      = 0         !> number of registered item
  type(vars),                 private, allocatable :: History_vars(:)
  logical,                    private, allocatable :: History_axis_written(:)           !> Axis for this file is already written?

  integer,                    private, parameter   :: History_axis_limit    = 100       !> number limit of axes
  integer,                    private              :: History_axis_count    =   0
  type(axis),                 private              :: History_axis(History_axis_limit)

  integer,                    private, parameter   :: History_assoc_limit   = 20        !> number limit of associated coordinates
  integer,                    private              :: History_assoc_count   =  0
  type(assoc),                private              :: History_assoc(History_assoc_limit)

  real(DP),                   private, parameter   :: eps                   = 1.D-10    !> epsilon for timesec

  integer,                    private              :: laststep_write = -1
  logical,                    private              :: firsttime      = .true.
  character(len=LOG_LMSG),    private              :: message        = ''
  logical,                    private              :: debug          = .false.

  integer,                    private              :: History_io_buffer_size            !>  internal buffer for PnetCDF

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  subroutine HistoryInit( &
       item_count,                &
       variant_count,             &
       isize,                     &
       jsize,                     &
       ksize,                     &
       master,                    &
       myrank,                    &
       title,                     &
       source,                    &
       institution,               &
       time_start,                &
       time_interval,             &
       time_units,                &
       time_since,                &
       default_basename,          &
       default_postfix_timelabel, &
       default_zcoord,            &
       default_tinterval,         &
       default_tunit,             &
       default_taverage,          &
       default_datatype,          &
       namelist_filename,         &
       namelist_fid               )
#if defined(PGI) || defined(SX)
    use dc_log, only: &
       LOG_master_nml
#endif
    use dc_calendar, only: &
       CalendarYmdhms2sec
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8, &
       File_preclist
    implicit none

    integer,          intent(out) :: item_count
    integer,          intent(out) :: variant_count
    integer,          intent(in)  :: isize
    integer,          intent(in)  :: jsize
    integer,          intent(in)  :: ksize
    integer,          intent(in)  :: master
    integer,          intent(in)  :: myrank
    character(len=*), intent(in)  :: title
    character(len=*), intent(in)  :: source
    character(len=*), intent(in)  :: institution
    real(DP),         intent(in)  :: time_start
    real(DP),         intent(in)  :: time_interval

    character(len=*), intent(in), optional :: time_units
    character(len=*), intent(in), optional :: time_since
    character(len=*), intent(in), optional :: default_basename
    logical,          intent(in), optional :: default_postfix_timelabel
    character(len=*), intent(in), optional :: default_zcoord
    real(DP),         intent(in), optional :: default_tinterval
    character(len=*), intent(in), optional :: default_tunit
    logical,          intent(in), optional :: default_taverage
    character(len=*), intent(in), optional :: default_datatype
    character(len=*), intent(in), optional :: namelist_filename
    integer         , intent(in), optional :: namelist_fid

    character(len=File_HLONG)  :: History_DEFAULT_BASENAME          !> Base name of the file
    logical                    :: History_DEFAULT_POSTFIX_TIMELABEL !> Add timelabel to the basename?
    character(len=File_HSHORT) :: History_DEFAULT_ZCOORD            !> Default z-coordinate
    real(DP)                   :: History_DEFAULT_TINTERVAL         !> Time interval
    character(len=File_HSHORT) :: History_DEFAULT_TUNIT             !> Time unit
    logical                    :: History_DEFAULT_TAVERAGE          !> Apply time average?
    character(len=File_HSHORT) :: History_DEFAULT_DATATYPE          !> Data type
                                                                    !> REAL4 : single precision
                                                                    !> REAL8 : double precision
    real(DP)                   :: History_OUTPUT_WAIT               !> Time length to suppress output
    character(len=File_HSHORT) :: History_OUTPUT_WAIT_TUNIT         !> Time unit
    real(DP)                   :: History_OUTPUT_SWITCH_TINTERVAL   !> Time interval to switch output file
    character(len=File_HSHORT) :: History_OUTPUT_SWITCH_TUNIT       !> Time unit

    NAMELIST / PARAM_HISTORY / &
       History_TITLE,                     &
       History_SOURCE,                    &
       History_INSTITUTION,               &
       History_TIME_UNITS,                &
       History_DEFAULT_BASENAME,          &
       History_DEFAULT_POSTFIX_TIMELABEL, &
       History_DEFAULT_ZCOORD,            &
       History_DEFAULT_TINTERVAL,         &
       History_DEFAULT_TUNIT,             &
       History_DEFAULT_TAVERAGE,          &
       History_DEFAULT_DATATYPE,          &
       History_OUTPUT_STEP0,              &
       History_OUTPUT_WAIT,               &
       History_OUTPUT_WAIT_TUNIT,         &
       History_OUTPUT_SWITCH_TINTERVAL,   &
       History_OUTPUT_SWITCH_TUNIT,       &
       History_ERROR_PUTMISS,             &
       debug

    character(len=File_HSHORT) :: ITEM              !> name of variable (in the code)
    character(len=File_HSHORT) :: OUTNAME           !> name of variable (for output)
    character(len=File_HLONG)  :: BASENAME          !> base name of the file
    logical                    :: POSTFIX_TIMELABEL !> Add timelabel to the basename?
    character(len=File_HSHORT) :: ZCOORD            !> z-coordinate
    real(DP)                   :: TINTERVAL         !> time interval
    character(len=File_HSHORT) :: TUNIT             !> time unit
    logical                    :: TAVERAGE          !> apply time average?
    character(len=File_HSHORT) :: DATATYPE          !> data type

    NAMELIST / HISTITEM / &
       ITEM,              &
       OUTNAME,           &
       BASENAME,          &
       POSTFIX_TIMELABEL, &
       ZCOORD,            &
       TINTERVAL,         &
       TUNIT,             &
       TAVERAGE,          &
       DATATYPE

    integer  :: array_size
    integer  :: reqid
    real(DP) :: dtsec
    integer  :: dstep

    integer                    :: id1, id2, count
    character(len=File_HSHORT) :: item1, item2

    integer  :: fid, ierr
    integer  :: n, id

    intrinsic size
    !---------------------------------------------------------------------------

    call Log('I','')
    call Log('I','###### Module[HISTORY] / Origin[gtoollib]')

    ! setup
    History_master      = master
    History_myrank      = myrank

    History_STARTDAYSEC = time_start
    History_DTSEC       = time_interval
    if ( present(time_since) ) then
       History_TIME_SINCE = time_since
    else
       History_TIME_SINCE = ''
    endif

    History_TIME_UNITS                = 'seconds' !> Unit for time axis
    History_DEFAULT_BASENAME          = ''        !> Base name of the file
    History_DEFAULT_POSTFIX_TIMELABEL = .false.   !> Add timelabel to the basename?
    History_DEFAULT_ZCOORD            = ''        !> Default z-coordinate
    History_DEFAULT_TINTERVAL         = -1.0_DP   !> Time interval
    History_DEFAULT_TUNIT             = 'SEC'     !> Time unit
    History_DEFAULT_TAVERAGE          = .false.   !> Apply time average?
    History_DEFAULT_DATATYPE          = 'REAL4'   !> Data type
    History_OUTPUT_WAIT               =  0.0_DP   !> Time length to suppress output
    History_OUTPUT_WAIT_TUNIT         = 'SEC'     !> Time unit
    History_OUTPUT_SWITCH_TINTERVAL   = -1.0_DP   !> Time interval to switch output file
    History_OUTPUT_SWITCH_TUNIT       = 'SEC'     !> Time unit

    !--- read namelist
    History_TITLE       = title
    History_SOURCE      = source
    History_INSTITUTION = institution
    if( present(time_units)                ) History_TIME_UNITS                = time_units
    if( present(default_basename)          ) History_DEFAULT_BASENAME          = default_basename
    if( present(default_postfix_timelabel) ) History_DEFAULT_POSTFIX_TIMELABEL = default_postfix_timelabel
    if( present(default_zcoord)            ) History_DEFAULT_ZCOORD            = default_zcoord
    if( present(default_tinterval)         ) History_DEFAULT_TINTERVAL         = default_tinterval
    if( present(default_tunit)             ) History_DEFAULT_TUNIT             = default_tunit
    if( present(default_taverage)          ) History_DEFAULT_TAVERAGE          = default_taverage
    if( present(default_datatype)          ) History_DEFAULT_DATATYPE          = default_datatype

    fid = -1
    if ( present(namelist_fid) ) then
       fid = namelist_fid
    elseif( present(namelist_filename) ) then
       if ( namelist_filename /= '' ) then
          open( unit   = fid,                     &
                file   = trim(namelist_filename), &
                form   = 'formatted',             &
                status = 'old'                    )
       endif
    endif

    if ( fid <= 0 ) then
       call Log('E','xxx No namelist file is specified. Check!')
    endif

    rewind(fid)
    read(fid,nml=PARAM_HISTORY,iostat=ierr)
    if    ( ierr < 0 ) then !--- missing
       call Log('I','*** Not found namelist. Default used.')
    elseif( ierr > 0 ) then !--- fatal error
       call Log('E','xxx Not appropriate names in namelist PARAM_HISTORY. Check!')
    endif

#if defined(PGI) || defined(SX)
    if ( LOG_master_nml ) write(LOG_fid_nml,nml=PARAM_HISTORY)
#else
    write(message,nml=PARAM_HISTORY)
    call Log_nml('I',message)
#endif

    if ( History_OUTPUT_WAIT >= 0.0_DP ) then
       call CalendarYmdhms2sec( dtsec, History_OUTPUT_WAIT, History_OUTPUT_WAIT_TUNIT )
       History_OUTPUT_WAIT_STEP = int( dtsec / History_DTSEC )
    else
       write(message,*) 'xxx History_OUTPUT_WAIT must be positive. STOP'
       call Log('E',message)
    endif

    if ( History_OUTPUT_SWITCH_TINTERVAL >= 0.0_DP ) then
       call CalendarYmdhms2sec( dtsec, History_OUTPUT_SWITCH_TINTERVAL, History_OUTPUT_SWITCH_TUNIT )
       History_OUTPUT_SWITCH_STEP = int( dtsec / History_DTSEC )
    else
       History_OUTPUT_SWITCH_STEP = -1
    endif
    History_OUTPUT_SWITCH_LASTSTEP = 0

    array_size = isize * jsize * ksize

    ! count history request
    History_req_count = 0
    rewind(fid)
    do n = 1, History_req_limit
       ITEM      = ''
       OUTNAME   = 'undefined'
       BASENAME  = History_DEFAULT_BASENAME

       read(fid,nml=HISTITEM,iostat=ierr)
       if( ierr /= 0 ) exit
       if( BASENAME == '' .OR. ITEM == '' .OR. OUTNAME == '' ) cycle ! invalid HISTITEM

       History_req_count = History_req_count + 1
    enddo

    item_count    = History_req_count
    variant_count = 1

    if    ( History_req_count > History_req_limit ) then
       write(message,*) 'xxx request of history file is exceed! n >', History_req_limit
       call Log('E',message)
    elseif( History_req_count == 0 ) then
       call Log('I','*** No history file specified.')
       return
    endif

    allocate( History_req(History_req_count) )

    ! allows PnetCDF to use an internal buffer to aggregate write requests
    History_io_buffer_size = array_size * History_req_count * 8

    ! read history request
    reqid   = 0
    if ( fid > 0 ) rewind(fid)
    do n = 1, History_req_limit
       ! set default
       ITEM              = ''
       OUTNAME           = 'undefined'
       BASENAME          = History_DEFAULT_BASENAME
       POSTFIX_TIMELABEL = History_DEFAULT_POSTFIX_TIMELABEL
       ZCOORD            = History_DEFAULT_ZCOORD
       TINTERVAL         = History_DEFAULT_TINTERVAL
       TUNIT             = History_DEFAULT_TUNIT
       TAVERAGE          = History_DEFAULT_TAVERAGE
       DATATYPE          = History_DEFAULT_DATATYPE

       read(fid,nml=HISTITEM,iostat=ierr)
       if( ierr /= 0 ) exit
       if( BASENAME == '' .OR. ITEM == '' .OR. OUTNAME == '' ) cycle ! invalid HISTITEM

       if ( LOG_fid_nml /= LOG_fid ) then
#if defined(PGI) || defined(SX)
          if ( LOG_master_nml ) write(LOG_fid_nml,nml=HISTITEM)
#else
          write(message,nml=HISTITEM)
          call Log_nml('I',message)
#endif
       endif

       ! check duplicated request
       if ( OUTNAME == 'undefined' ) OUTNAME = ITEM ! set default name
       do id = 1, reqid
          if ( History_req(id)%outname == OUTNAME ) then
             write(message,*) &
             'xxx Same name of history output is already registered. Check!', trim(OUTNAME)
             call Log('E',message)
          endif
       enddo

       reqid = reqid + 1

       History_req(reqid)%item              = ITEM
       History_req(reqid)%outname           = OUTNAME
       History_req(reqid)%basename          = BASENAME
       History_req(reqid)%postfix_timelabel = POSTFIX_TIMELABEL
       if( History_OUTPUT_SWITCH_STEP >= 0 ) History_req(reqid)%postfix_timelabel = .true. ! force true
       History_req(reqid)%zcoord            = ZCOORD
       History_req(reqid)%taverage          = TAVERAGE

       call CalendarYmdhms2sec( dtsec, TINTERVAL, TUNIT )
       dstep = int( dtsec / History_DTSEC )

       if ( dtsec <= 0.D0 ) then
          write(message,*) &
          'xxx Not appropriate time interval. Check!', trim(ITEM), TINTERVAL, trim(TUNIT)
          call Log('E',message)
       endif

       if ( abs(dtsec-real(dstep,kind=DP)*History_DTSEC ) > eps ) then
          write(message,*) &
          'xxx time interval must be a multiple of delta t. (interval,dt)=', dtsec, History_DTSEC
          call Log('E',message)
       endif

       History_req(reqid)%dstep  = dstep

       if    ( DATATYPE == 'REAL4' ) then
          History_req(reqid)%dtype  = File_REAL4
       elseif( DATATYPE == 'REAL8' ) then
          History_req(reqid)%dtype  = File_REAL8
       else
          write(message,*) 'xxx Not appropriate DATATYPE. Check!', DATATYPE
          call Log('E',message)
       endif

       History_req(reqid)%registered = .false.
    enddo

    call Log('I','')
    write(message,'(A,I4)') '*** Number of requested history item             : ', History_req_count
    call Log('I',message)
    write(message,'(A,A)')  '*** Output default data type                     : ', History_DEFAULT_DATATYPE
    call Log('I',message)
    write(message,'(A,L4)') '*** Output value at the initial step?            : ', History_OUTPUT_STEP0
    call Log('I',message)
    if ( History_OUTPUT_WAIT_STEP > 0 ) then
       write(message,'(A,I8)') '*** Time when the output is suppressed [step]    : ', History_OUTPUT_WAIT_STEP
       call Log('I',message)
    endif
    if ( History_OUTPUT_SWITCH_STEP >= 0 ) then
       write(message,'(A,I8)') '*** Interval for switching the file [step]       : ', History_OUTPUT_SWITCH_STEP
       call Log('I',message)
    endif
    write(message,'(A,L4)') '*** Check if requested item is not registered?   : ', History_ERROR_PUTMISS
    call Log('I',message)

    if ( .NOT. present(namelist_fid) ) then
       if( fid > 0 ) close(fid)
    endif

    History_id_count = 0
    allocate( History_vars        (  History_req_count) )
    allocate( History_axis_written(0:History_req_count) )

    ! count number of items and variants
    do id1 = 1, item_count
       item1 = History_req(id1)%item
       count = 1
       do id2 = id1, item_count
          item2 = History_req(id2)%item
          if( item1 == item2 ) count = count + 1
       enddo
       variant_count = max( variant_count, count)
    enddo

    return
  end subroutine HistoryInit

  !-----------------------------------------------------------------------------
  subroutine HistoryCheck( &
       existed,   &
       item,      &
       zcoord     )
    implicit none

    logical,          intent(out)          :: existed
    character(len=*), intent(in)           :: item
    character(len=*), intent(in), optional :: zcoord

    integer :: max_count
    integer :: n
    !---------------------------------------------------------------------------

    existed = .false.

    max_count = min( History_id_count, History_req_count )

    !--- search existing item
    do n = 1, max_count
       if ( item == History_vars(n)%item ) then ! match (at least one) existing item
          !--- check z-coordinate
          if ( present(zcoord) ) then
             if ( History_vars(n)%zcoord == zcoord ) then
                existed = .true.
                return
             endif
          else
             existed = .true.
             return
          endif
       endif
    enddo

    return
  end subroutine HistoryCheck

  !-----------------------------------------------------------------------------
  subroutine HistoryAddVariable( &
       nregist,   &
       item,      &
       dims,      &
       desc,      &
       units,     &
       mapping,   &
       now_step,  &
       zcoord,    &
       start,     &
       count      )
    use gtool_file_h, only: &
       File_dtypelist
    implicit none

    integer,           intent(out) :: nregist
    character(len=*),  intent(in)  :: item
    character(len=*),  intent(in)  :: dims(:)
    character(len=*),  intent(in)  :: desc
    character(len=*),  intent(in)  :: units
    character(len=*),  intent(in)  :: mapping
    integer,           intent(in)  :: now_step

    character(len=*),  intent(in), optional :: zcoord
    integer,           intent(in), optional :: start(:) ! global subarray starting indices of this process's write request
    integer,           intent(in), optional :: count(:) ! lengths of this process's write request along each dimension

    integer :: reqid, id
    integer :: ndims
    logical :: existed
    integer :: n

    intrinsic size
    !---------------------------------------------------------------------------

    nregist = 0

    call HistoryCheck( existed, & ! [OUT]
                       item,    & ! [IN]
                       zcoord   ) ! [IN]

    if ( .NOT. existed ) then ! request-register matching check

       do reqid = 1, History_req_count

          ! note: plural requests are allowed for each item
          if ( item == History_req(reqid)%item ) then

             if ( present(zcoord) ) then
                if ( History_req(reqid)%zcoord /= zcoord ) cycle
             endif

             History_req(reqid)%registered = .true.

             existed = .true.
             nregist = nregist + 1

             History_id_count = History_id_count + 1
             id               = History_id_count

             History_vars(id)%item              = History_req(reqid)%item
             History_vars(id)%outname           = History_req(reqid)%outname
             History_vars(id)%basename          = History_req(reqid)%basename
             History_vars(id)%postfix_timelabel = History_req(reqid)%postfix_timelabel
             History_vars(id)%zcoord            = History_req(reqid)%zcoord
             History_vars(id)%dstep             = History_req(reqid)%dstep
             History_vars(id)%taverage          = History_req(reqid)%taverage
             History_vars(id)%dtype             = History_req(reqid)%dtype

             History_vars(id)%fid               = -1
             History_vars(id)%vid               = -1
             History_vars(id)%desc              = desc
             History_vars(id)%units             = units
             History_vars(id)%mapping           = mapping

             ! history variable has been reshaped to 1D, we preserve the
             ! original shape in count(:) and History_count(:,id)
             ! History_ndims(id) stores number of dimensions of original shape
             ndims = size(dims)

             History_vars(id)%ndims             = ndims
             History_vars(id)%dims (1:ndims)    = dims(1:ndims)
             History_vars(id)%start(:)          = 1
             History_vars(id)%count(:)          = 1
             if ( present(start) ) History_vars(id)%start(:) = start(:)
             if ( present(count) ) History_vars(id)%count(:) = count(:)

             History_vars(id)%waitstep          = History_OUTPUT_WAIT_STEP
             if ( History_OUTPUT_STEP0 .AND. now_step == 1 ) then
                History_vars(id)%laststep_write = 1 - History_vars(id)%dstep
             else
                History_vars(id)%laststep_write = 1
             endif
             History_vars(id)%laststep_put      = History_vars(id)%laststep_write
             History_vars(id)%flag_clear        = .true.
             History_vars(id)%size              = -1

             History_vars(id)%timesum           = 0.0_DP

             if ( debug ) then
                write(message,*) '*** [HIST] Item registration No.= ', id
                call Log('I',message)
                write(message,*) '] Item name                      : ', trim(History_vars(id)%item)
                call Log('I',message)
                write(message,*) '] Output name                    : ', trim(History_vars(id)%outname)
                call Log('I',message)
                write(message,*) '] Description                    : ', trim(History_vars(id)%desc)
                call Log('I',message)
                write(message,*) '] Unit                           : ', trim(History_vars(id)%units)
                call Log('I',message)
                write(message,*) '] Basename of output file        : ', trim(History_vars(id)%basename)
                call Log('I',message)
                write(message,*) '] Add timelabel to the filename? : ', History_vars(id)%postfix_timelabel
                call Log('I',message)
                write(message,*) '] Z-coordinate                   : ', trim(History_vars(id)%zcoord)
                call Log('I',message)
                write(message,*) '] Interval [step]                : ', History_vars(id)%dstep
                call Log('I',message)
                write(message,*) '] Time Average?                  : ', History_vars(id)%taverage
                call Log('I',message)
                write(message,*) '] Datatype                       : ', trim(File_dtypelist(History_vars(id)%dtype))
                call Log('I',message)
                write(message,*) '] axis name                      : ', ( trim(History_vars(id)%dims(n))//" ", n=1, ndims )
                call Log('I',message)
                call Log('I','')
             endif

          endif ! match item?

       enddo

    endif ! new items?

    return
  end subroutine HistoryAddVariable

  !-----------------------------------------------------------------------------
  subroutine HistoryFileCreate( &
       id,        &
       now_step,  &
       timelabel, &
       options,   &
       comm,      &
       existed    )
    use mpi, only: &
       MPI_COMM_NULL
    use gtool_file, only: &
       FileCreate,                   &
       FileSetOption,                &
       FileDefAxis,                  &
       FileDefAssociatedCoordinates, &
       FileAttachBuffer,             &
       FileAddVariable,              &
       FileSetAttribute
    implicit none

    integer,           intent(in)  :: id
    integer,           intent(in)  :: now_step
    character(len=*),  intent(in)  :: timelabel

    character(len=*),  intent(in),  optional :: options ! 'filetype1:key1=val1&filetype2:key2=val2&...'
    integer,           intent(in),  optional :: comm    ! MPI communicator
    logical,           intent(out), optional :: existed

    logical                   :: shared_file_io
    character(len=File_HMID)  :: tunits
    character(len=File_HLONG) :: basename_mod
    logical                   :: fileexisted
    integer                   :: dim_size
    integer                   :: ndims
    real(DP)                  :: dtsec

    integer :: ic, ie, is, lo
    integer :: m
    !---------------------------------------------------------------------------

    if ( present(existed) ) existed = .true.

    if ( History_vars(id)%fid < 0 ) then ! time to create file

       ! check whether shared-file I/O method is enabled
       shared_file_io = .false.
       if ( present(comm) .AND. comm .NE. MPI_COMM_NULL ) shared_file_io = .true.

       if ( History_TIME_SINCE == '' ) then
          tunits = trim(History_TIME_UNITS)
       else
          tunits = trim(History_TIME_UNITS)//' since '//trim(History_TIME_SINCE)
       endif

       if ( History_vars(id)%postfix_timelabel ) then
          basename_mod = trim(History_vars(id)%basename)//'_'//trim(timelabel)
       else
          basename_mod = trim(History_vars(id)%basename)
       endif

       call FileCreate( History_vars(id)%fid, & ! [OUT]
                        fileexisted,          & ! [OUT]
                        basename_mod,         & ! [IN]
                        History_TITLE,        & ! [IN]
                        History_SOURCE,       & ! [IN]
                        History_INSTITUTION,  & ! [IN]
                        History_master,       & ! [IN]
                        History_myrank,       & ! [IN]
                        time_units = tunits,  & ! [IN]
                        comm       = comm     ) ! [IN]

       if ( .NOT. fileexisted ) then ! new file

          ! write options
          if ( present(options) ) then
             ic = -1 ! index of ':'
             ie = -1 ! index of '='
             is =  1 ! start index
             lo = len_trim(options)
             do m = 1, lo+1
                if ( m == lo+1 .OR. options(m:m) == '&' ) then
                   if ( ic == -1 .OR. ie == -1 ) then
                      call Log('E','xxx option is invalid: '//trim(options))
                   endif

                   call FileSetOption( History_vars(id)%fid, & ! [IN]
                                       options(is  :ic-1),   & ! [IN]
                                       options(ic+1:ie-1),   & ! [IN]
                                       options(ie+1:m -1)    ) ! [IN]

                   ic = -1
                   ie = -1
                   is = m+1
                elseif( options(m:m) == ':' ) then
                   ic = m
                elseif( options(m:m) == '=' ) then
                   ie = m
                endif
             enddo
          endif

          ! define registered history axis variables in the newly created file
          ! actual writing axis variables are deferred to HistoryWriteAxes
          do m = 1, History_axis_count
             if ( shared_file_io ) then ! for shared-file I/O, define axis in its global size
                dim_size = History_axis(m)%gdim_size ! axis global size
             else
                dim_size = History_axis(m)%dim_size
             endif

             call FileDefAxis( History_vars(id)%fid,  & ! [IN]
                               History_axis(m)%name,  & ! [IN]
                               History_axis(m)%desc,  & ! [IN]
                               History_axis(m)%units, & ! [IN]
                               History_axis(m)%dim,   & ! [IN]
                               History_axis(m)%dtype, & ! [IN]
                               dim_size               ) ! [IN]

             if ( History_axis(m)%down ) then
                call FileSetAttribute( History_vars(id)%fid, History_axis(m)%name, 'positive', 'down' )
             endif
          enddo

          ! define registered history associated coordinate variables in the newly created file
          ! actual writing coordinate variables are deferred to HistoryWriteAxes
          do m = 1, History_assoc_count
             ndims = History_assoc(m)%ndims

             call FileDefAssociatedCoordinates( History_vars(id)%fid,           & ! [IN]
                                                History_assoc(m)%name,          & ! [IN]
                                                History_assoc(m)%desc,          & ! [IN]
                                                History_assoc(m)%units,         & ! [IN]
                                                History_assoc(m)%dims(1:ndims), & ! [IN]
                                                History_assoc(m)%dtype          ) ! [IN]
          enddo

          ! allows PnetCDF to allocate an internal buffer of size io_buffer_size
          ! to aggregate write requests for history variables
          call FileAttachBuffer( History_vars(id)%fid, History_io_buffer_size )

          History_axis_written(History_vars(id)%fid) = .false.

          if ( present(existed) ) existed = .false.

       endif ! new file?

    endif

    if ( History_vars(id)%vid < 0 ) then ! time to add
       ! Add new variable
       ndims = History_vars(id)%ndims

       dtsec = real(History_vars(id)%dstep,kind=DP) * History_DTSEC

       call FileAddVariable( History_vars(id)%vid,           & ! [OUT]
                             History_vars(id)%fid,           & ! [IN]
                             History_vars(id)%outname,       & ! [IN]
                             History_vars(id)%desc,          & ! [IN]
                             History_vars(id)%units,         & ! [IN]
                             History_vars(id)%dims(1:ndims), & ! [IN]
                             History_vars(id)%dtype,         & ! [IN]
                             dtsec,                          & ! [IN]
                             History_vars(id)%taverage       ) ! [IN]


       if ( History_vars(id)%mapping /= "" ) then
          call FileSetAttribute( History_vars(id)%fid,     &
                                 History_vars(id)%outname, &
                                 'grid_mapping',           &
                                 History_vars(id)%mapping  )
       endif
    endif

    return
  end subroutine HistoryFileCreate

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAxis
  !-----------------------------------------------------------------------------
  subroutine HistoryPutAxisSP( &
       name,     &
       desc,     &
       units,    &
       dim,      &
       var,      &
       datatype, &
       down,     &
       gsize,    &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(SP),         intent(in) :: var(:)

    character(len=*), intent(in), optional :: datatype
    logical,          intent(in), optional :: down
    integer,          intent(in), optional :: gsize ! global dim size
    integer,          intent(in), optional :: start ! global subarray start indices

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL4
    endif

    dim_size = size(var)

    if ( History_axis_count < History_axis_limit ) then
       History_axis_count = History_axis_count + 1
       id                 = History_axis_count

       allocate( History_axis(id)%var(dim_size) )

       History_axis(id)%name     = name
       History_axis(id)%desc     = desc
       History_axis(id)%units    = units
       History_axis(id)%dim      = dim
       History_axis(id)%dtype    = dtype
       History_axis(id)%dim_size = dim_size
       History_axis(id)%var(:)   = real(var(:),kind=DP)

       if ( present(down) ) then
          History_axis(History_axis_count)%down = down
       else
          History_axis(History_axis_count)%down = .false.
       endif
       if ( present(gsize) ) &  ! global dimension size
          History_axis(History_axis_count)%gdim_size = gsize
       if ( present(start) ) then  ! global subarray starting indices
          History_axis(History_axis_count)%start(1) = start
       else
          History_axis(History_axis_count)%start(1) = 1
       end if
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPutAxisSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPutAxisDP( &
       name,     &
       desc,     &
       units,    &
       dim,      &
       var,      &
       datatype, &
       down,     &
       gsize,    &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(DP),         intent(in) :: var(:)

    character(len=*), intent(in), optional :: datatype
    logical,          intent(in), optional :: down
    integer,          intent(in), optional :: gsize ! global dim size
    integer,          intent(in), optional :: start ! global subarray start indices

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL8
    endif

    dim_size = size(var)

    if ( History_axis_count < History_axis_limit ) then
       History_axis_count = History_axis_count + 1
       id                 = History_axis_count

       allocate( History_axis(id)%var(dim_size) )

       History_axis(id)%name     = name
       History_axis(id)%desc     = desc
       History_axis(id)%units    = units
       History_axis(id)%dim      = dim
       History_axis(id)%dtype    = dtype
       History_axis(id)%dim_size = dim_size
       History_axis(id)%var(:)   = real(var(:),kind=DP)

       if ( present(down) ) then
          History_axis(History_axis_count)%down = down
       else
          History_axis(History_axis_count)%down = .false.
       endif
       if ( present(gsize) ) &  ! global dimension size
          History_axis(History_axis_count)%gdim_size = gsize
       if ( present(start) ) then  ! global subarray starting indices
          History_axis(History_axis_count)%start(1) = start
       else
          History_axis(History_axis_count)%start(1) = 1
       end if
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPutAxisDP

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAssociatedCoordinates
  !-----------------------------------------------------------------------------
  subroutine HistoryPut1DAssociatedCoordinatesSP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL4
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 1
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:1) = dims(1:1)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:1) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:1) = start(1:1)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut1DAssociatedCoordinatesSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut1DAssociatedCoordinatesDP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL8
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 1
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:1) = dims(1:1)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:1) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:1) = start(1:1)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut1DAssociatedCoordinatesDP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut2DAssociatedCoordinatesSP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL4
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 2
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:2) = dims(1:2)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:2) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:2) = start(1:2)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut2DAssociatedCoordinatesSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut2DAssociatedCoordinatesDP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL8
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 2
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:2) = dims(1:2)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:2) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:2) = start(1:2)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut2DAssociatedCoordinatesDP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut3DAssociatedCoordinatesSP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL4
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 3
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:3) = dims(1:3)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:3) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:3) = start(1:3)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut3DAssociatedCoordinatesSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut3DAssociatedCoordinatesDP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL8
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 3
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:3) = dims(1:3)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:3) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:3) = start(1:3)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut3DAssociatedCoordinatesDP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut4DAssociatedCoordinatesSP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL4
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 4
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:4) = dims(1:4)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:4) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:4) = start(1:4)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut4DAssociatedCoordinatesSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut4DAssociatedCoordinatesDP( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = File_REAL8
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = 4
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:4) = dims(1:4)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       History_assoc(id)%count(1:4) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:4) = start(1:4)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut4DAssociatedCoordinatesDP

  !-----------------------------------------------------------------------------
  ! interface HistorySetGlobalAttribute
  !-----------------------------------------------------------------------------
  subroutine HistorySetGlobalAttributeText( &
       key, &
       val  )
    use gtool_file, only: &
       FileSetGlobalAttribute
    implicit none

    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetGlobalAttribute( fid, key, val ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine HistorySetGlobalAttributeInt( &
       key, &
       val  )
    use gtool_file, only: &
       FileSetGlobalAttribute
    implicit none

    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetGlobalAttribute( fid, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetGlobalAttributeInt

  !-----------------------------------------------------------------------------
  subroutine HistorySetGlobalAttributeFloat( &
       key, &
       val  )
    use gtool_file, only: &
       FileSetGlobalAttribute
    implicit none

    character(len=*), intent(in) :: key
    real(SP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetGlobalAttribute( fid, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetGlobalAttributeFloat

  !-----------------------------------------------------------------------------
  subroutine HistorySetGlobalAttributeDouble( &
       key, &
       val  )
    use gtool_file, only: &
       FileSetGlobalAttribute
    implicit none

    character(len=*), intent(in) :: key
    real(DP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetGlobalAttribute( fid, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetGlobalAttributeDouble

  !-----------------------------------------------------------------------------
  ! interface HistorySetAttribute
  !-----------------------------------------------------------------------------
  subroutine HistorySetAttributeText( &
       varname, &
       key,     &
       val      )
    use gtool_file, only: &
       FileSetAttribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetAttribute( fid, varname, key, val ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetAttributeText

  !-----------------------------------------------------------------------------
  subroutine HistorySetAttributeInt( &
       varname, &
       key,     &
       val      )
    use gtool_file, only: &
       FileSetAttribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetAttribute( fid, varname, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetAttributeInt

  !-----------------------------------------------------------------------------
  subroutine HistorySetAttributeFloat( &
       varname, &
       key,     &
       val      )
    use gtool_file, only: &
       FileSetAttribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    real(SP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetAttribute( fid, varname, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetAttributeFloat

  !-----------------------------------------------------------------------------
  subroutine HistorySetAttributeDouble( &
       varname, &
       key,     &
       val      )
    use gtool_file, only: &
       FileSetAttribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    real(DP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileSetAttribute( fid, varname, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetAttributeDouble

  !-----------------------------------------------------------------------------
  subroutine HistorySetMapping( &
       mapping )
    use gtool_file, only: &
       FileAddAssociatedVariable, &
       FileSetAttribute
    implicit none

    character(len=*), intent(in) :: mapping

    logical :: existed
    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileAddAssociatedVariable( fid,     & ! [IN]
                                          mapping, & ! [IN]
                                          existed  ) ! [OUT]

          if ( .NOT. existed ) then
             call FileSetAttribute( fid, mapping, "grid_mapping_name", mapping ) ! [IN]
          endif

          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistorySetMapping

  !-----------------------------------------------------------------------------
  subroutine HistoryQuery( &
       item,     &
       step_now, &
       answer    )
    implicit none

    character(len=*), intent(in)  :: item
    integer,          intent(in)  :: step_now
    logical,          intent(out) :: answer

    integer :: id
    !---------------------------------------------------------------------------

    answer  = .false.

    ! note: multiple put may be necessary for the item
    do id = 1, History_id_count
       if ( item == History_vars(id)%item ) then
          if    ( History_vars(id)%taverage ) then
             answer = .true.
          elseif( step_now >= History_vars(id)%laststep_write + History_vars(id)%dstep ) then
             answer = .true.
          endif
       endif
    enddo

    return
  end subroutine HistoryQuery

  !-----------------------------------------------------------------------------
  ! interface HistoryPut
  !-----------------------------------------------------------------------------
  subroutine HistoryPut0DIdSP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var

    real(DP) :: dt
    integer  :: idx

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif


    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = 1
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
          idx = 1
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var * dt

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
          idx = 1
          History_vars(id)%varsum(idx) = real(var,kind=DP)

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut0DIdSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut0DIdDP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var

    real(DP) :: dt
    integer  :: idx

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif


    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = 1
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
          idx = 1
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var * dt

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
          idx = 1
          History_vars(id)%varsum(idx) = real(var,kind=DP)

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut0DIdDP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut1DIdSP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var(:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(1)
    integer  :: i

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = vsize(1)
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
       do i = 1, vsize(1)
          idx = i
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var(i) * dt
       enddo

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
       do i = 1, vsize(1)
          idx = i
          History_vars(id)%varsum(idx) = real(var(i),kind=DP)
       enddo

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut1DIdSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut1DIdDP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var(:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(1)
    integer  :: i

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = vsize(1)
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
       do i = 1, vsize(1)
          idx = i
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var(i) * dt
       enddo

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
       do i = 1, vsize(1)
          idx = i
          History_vars(id)%varsum(idx) = real(var(i),kind=DP)
       enddo

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut1DIdDP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut2DIdSP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var(:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(2)
    integer  :: i, j

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = vsize(1) * vsize(2)
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var(i,j) * dt
       enddo
       enddo

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          History_vars(id)%varsum(idx) = real(var(i,j),kind=DP)
       enddo
       enddo

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut2DIdSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut2DIdDP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var(:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(2)
    integer  :: i, j

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = vsize(1) * vsize(2)
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var(i,j) * dt
       enddo
       enddo

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          History_vars(id)%varsum(idx) = real(var(i,j),kind=DP)
       enddo
       enddo

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut2DIdDP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut3DIdSP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var(:,:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(3)
    integer  :: i, j, k

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = vsize(1) * vsize(2) * vsize(3)
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var(i,j,k) * dt
       enddo
       enddo
       enddo

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          History_vars(id)%varsum(idx) = real(var(i,j,k),kind=DP)
       enddo
       enddo
       enddo

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut3DIdSP

  !-----------------------------------------------------------------------------
  subroutine HistoryPut3DIdDP( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var(:,:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(3)
    integer  :: i, j, k

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( History_vars(id)%size == -1 ) then
       History_vars(id)%size = vsize(1) * vsize(2) * vsize(3)
       allocate( History_vars(id)%varsum( History_vars(id)%size ) )
    end if

    if ( History_vars(id)%flag_clear ) then ! time to purge
       History_vars(id)%timesum    = 0.0_DP
       if ( History_vars(id)%taverage ) History_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( History_vars(id)%taverage ) then
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + var(i,j,k) * dt
       enddo
       enddo
       enddo

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          History_vars(id)%varsum(idx) = real(var(i,j,k),kind=DP)
       enddo
       enddo
       enddo

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%laststep_put = step_now
    History_vars(id)%flag_clear   = .false.

    return
  end subroutine HistoryPut3DIdDP

  !-----------------------------------------------------------------------------
  subroutine HistoryWriteAll( &
       step_now )
    use gtool_file, only: &
       FileFlush
    implicit none
    integer, intent(in) :: step_now

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    ! Write registered history variables to history file
    do id = 1, History_id_count
       call HistoryWrite( id,      & ! [IN]
                          step_now ) ! [IN]
    enddo

    ! when using PnetCDF, the above HistoryWrite() only posts write requests
    ! Now we need to commit the requests to the file
    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileFlush( fid )
          prev_fid = fid
       endif
    enddo

    ! check time to switching output file
    if (       History_OUTPUT_SWITCH_STEP >= 0                                      &
         .AND. step_now-History_OUTPUT_SWITCH_LASTSTEP > History_OUTPUT_SWITCH_STEP ) then

       call HistoryFinalize

       write(message,'(A)') '*** History file is switched.'
       call Log('I',message)

       do id = 1, History_id_count
          History_vars(id)%fid = -1 ! reset
          History_vars(id)%vid = -1 ! reset
       enddo

       History_OUTPUT_SWITCH_LASTSTEP = step_now-1
    endif

    return
  end subroutine HistoryWriteAll

  !-----------------------------------------------------------------------------
  subroutine HistoryWriteAxes( &
       axis_written_first )
    use gtool_file, only: &
       FileEndDef,    &
       FileFlush,     &
       FileWriteAxis, &
       FileWriteAssociatedCoordinates
    implicit none

    logical, intent(out) :: axis_written_first

    integer :: start(1)
    integer :: m, id, fid
    !---------------------------------------------------------------------------

    axis_written_first = .false.

    if( History_req_count  == 0 ) return
    if( History_axis_count == 0 ) return

    do id = 1, History_id_count

       fid = History_vars(id)%fid

       if( fid < 0 .OR. History_axis_written(fid) ) cycle

       call FileEndDef( fid )

       ! write registered history variables to file
       do m = 1, History_axis_count
          if ( History_axis(m)%start(1) > 0 ) then
             start(1) = History_axis(m)%start(1)

             call FileWriteAxis( fid,                  & ! [IN]
                                 History_axis(m)%name, & ! [IN]
                                 History_axis(m)%var,  & ! [IN]
                                 start                 ) ! [IN]
          endif
       enddo

       do m = 1, History_assoc_count
          call FileWriteAssociatedCoordinates( fid,                    & ! [IN]
                                               History_assoc(m)%name,  & ! [IN]
                                               History_assoc(m)%var,   & ! [IN]
                                               History_assoc(m)%start, & ! [IN]
                                               History_assoc(m)%count, & ! [IN]
                                               History_assoc(m)%ndims  ) ! [IN]
       enddo

       ! for PnetCDF I/O, flush all pending nonblocking write requests
       call FileFlush( fid )

       ! mark the axes have been written
       History_axis_written(fid) = .true.
       axis_written_first        = .true.

    enddo

    return
  end subroutine HistoryWriteAxes

  !-----------------------------------------------------------------------------
  subroutine HistoryWrite( &
       id,  &
       step_now )
    use dc_calendar, only: &
       CalendarSec2ymdhms
    use gtool_file, only: &
       FileWrite
    implicit none

    integer, intent(in) :: id
    integer, intent(in) :: step_now

    integer  :: isize
    real(DP) :: time_str, time_end
    real(DP) :: sec_str,  sec_end
    !---------------------------------------------------------------------------

    if( History_req_count == 0 ) return

    if ( step_now < History_vars(id)%laststep_write + History_vars(id)%dstep ) then
       return
    endif

    if ( History_vars(id)%flag_clear ) then
       if ( History_ERROR_PUTMISS ) then
          write(message,'(3A)') 'xxx The time interval of history output ', trim(History_vars(id)%item), &
                                ' and the time interval of its related scheme are inconsistent.'
          call Log('I',message)
          write(message,'(A)')  'xxx Please check the namelist PARAM_TIME, PARAM_HISTORY, and HISTITEM.'
          call Log('I',message)
          write(message,'(2A)') 'xxx Please set History_ERROR_PUTMISS in the namelist PARAM_HISTORY to .false.', &
                                ' when you want to disable this check.'
          call Log('I',message)

          write(message,'(4A)') 'xxx The time interval of history output ', trim(History_vars(id)%item), &
                                ' and the time interval of its related scheme are inconsistent.',        &
                                ' Please see detail in log file.'
          call Log('E',message)
       else
          write(message,'(2A)') '*** Output value is not updated in this step. NAME : ', &
                                trim(History_vars(id)%item)
          call Log('I',message)
       endif
    endif

    isize = History_vars(id)%size

    if ( .NOT. History_vars(id)%flag_clear .AND. History_vars(id)%taverage ) then
       History_vars(id)%varsum(1:isize) = History_vars(id)%varsum(1:isize) / History_vars(id)%timesum
    endif

    if ( firsttime ) then
       firsttime = .false.
       call HistoryOutputList
    endif

    if ( step_now > History_vars(id)%waitstep ) then
       if ( laststep_write < step_now ) then ! log only once in this step
          write(message,'(A)') '*** Output History'
          call Log('I',message)
       endif

       sec_str = History_STARTDAYSEC + real(History_vars(id)%laststep_write-1,kind=DP) * History_DTSEC
       sec_end = History_STARTDAYSEC + real(step_now                       -1,kind=DP) * History_DTSEC

       ! convert time units [sec]->[sec,min,hour,day,month,year]
       call CalendarSec2ymdhms( time_str, sec_str, History_TIME_UNITS )
       call CalendarSec2ymdhms( time_end, sec_end, History_TIME_UNITS )

       if ( History_vars(id)%count(1) > 0 ) then

          ! for one-file-per-process I/O method, History_vars(:)%count(1) == 1 always
          ! for one file shared by all processes, History_vars(:)%count(1) >= 0,
          ! being 0 indicates a 1D history variable, which will only be written by the
          ! south-most processes in parallel, or a z axis to be written by rank 0 only
          call FileWrite( History_vars(id)%fid,             & ! [IN]
                          History_vars(id)%vid,             & ! [IN]
                          History_vars(id)%varsum(1:isize), & ! [IN]
                          time_str,                         & ! [IN]
                          time_end,                         & ! [IN]
                          History_vars(id)%start,           & ! global subarray start indices
                          History_vars(id)%count,           & ! global subarray lengths
                          History_vars(id)%ndims            ) ! ndims before reshape
       end if
    else
       if ( laststep_write < step_now ) then
          write(message,'(A)') '*** Output History: Suppressed.'
          call Log('I',message)
       endif
    endif

    History_vars(id)%laststep_write = step_now
    History_vars(id)%flag_clear     = .true.

    laststep_write = step_now ! remember for multiple call in the same step

    return
  end subroutine HistoryWrite

  !-----------------------------------------------------------------------------
  ! interface HistoryGet
  !-----------------------------------------------------------------------------
  subroutine HistoryGet1DDP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(DP),         intent(out) :: var(:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FileRead( var,             & ! [OUT]
                   basename,        & ! [IN]
                   varname,         & ! [IN]
                   step,            & ! [IN]
                   History_myrank,  & ! [IN]
                   allow_missing_,  & ! [IN]
                   single_          ) ! [IN]

    return
  end subroutine HistoryGet1DDP

  !-----------------------------------------------------------------------------
  subroutine HistoryGet1DSP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(SP),         intent(out) :: var(:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FileRead( var,             & ! [OUT]
                   basename,        & ! [IN]
                   varname,         & ! [IN]
                   step,            & ! [IN]
                   History_myrank,  & ! [IN]
                   allow_missing_,  & ! [IN]
                   single_          ) ! [IN]

    return
  end subroutine HistoryGet1DSP

  !-----------------------------------------------------------------------------
  subroutine HistoryGet2DDP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(DP),         intent(out) :: var(:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FileRead( var,             & ! [OUT]
                   basename,        & ! [IN]
                   varname,         & ! [IN]
                   step,            & ! [IN]
                   History_myrank,  & ! [IN]
                   allow_missing_,  & ! [IN]
                   single_          ) ! [IN]

    return
  end subroutine HistoryGet2DDP

  !-----------------------------------------------------------------------------
  subroutine HistoryGet2DSP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(SP),         intent(out) :: var(:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FileRead( var,             & ! [OUT]
                   basename,        & ! [IN]
                   varname,         & ! [IN]
                   step,            & ! [IN]
                   History_myrank,  & ! [IN]
                   allow_missing_,  & ! [IN]
                   single_          ) ! [IN]

    return
  end subroutine HistoryGet2DSP

  !-----------------------------------------------------------------------------
  subroutine HistoryGet3DDP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(DP),         intent(out) :: var(:,:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FileRead( var,             & ! [OUT]
                   basename,        & ! [IN]
                   varname,         & ! [IN]
                   step,            & ! [IN]
                   History_myrank,  & ! [IN]
                   allow_missing_,  & ! [IN]
                   single_          ) ! [IN]

    return
  end subroutine HistoryGet3DDP

  !-----------------------------------------------------------------------------
  subroutine HistoryGet3DSP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(SP),         intent(out) :: var(:,:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FileRead( var,             & ! [OUT]
                   basename,        & ! [IN]
                   varname,         & ! [IN]
                   step,            & ! [IN]
                   History_myrank,  & ! [IN]
                   allow_missing_,  & ! [IN]
                   single_          ) ! [IN]

    return
  end subroutine HistoryGet3DSP

  !-----------------------------------------------------------------------------
  subroutine HistoryOutputList
    implicit none

    real(DP) :: dtsec
    integer  :: id
    !---------------------------------------------------------------------------

    if ( History_id_count /= History_req_count ) then

       write(message,'(A)') '*** [HIST] All of requested variable by the namelist HISTITEM did not find.'
       call Log('I',message)
       do id = 1, History_req_count
          write(message,'(A,A24,A,L1)') '*** NAME : ', History_req(id)%item, &
                                        ', registered? : ', History_req(id)%registered
          call Log('I',message)
       enddo
       write(message,'(2A)') '*** Please set History_ERROR_PUTMISS in the namelist PARAM_HISTORY to .false.', &
                             ' when you want to disable this check.'
       call Log('I',message)

       if ( History_ERROR_PUTMISS ) then
          write(message,'(A)') 'xxx Requested variables by the namelist HISTITEM did not find. Please see detail in log file.'
          call Log('E',message)
       endif
    endif

    call Log('I','')
    write(message,'(A)') '*** [HIST] Output item list '
    call Log('I',message)
    write(message,'(A,I4)') '*** Number of history item :', History_req_count
    call Log('I',message)
    write(message,'(2A)') 'ITEM                    :OUTNAME                 ', &
                          ':    size:interval[sec]:    step:timeavg?:zcoord'
    call Log('I',message)
    write(message,'(2A)') '=================================================', &
                          '================================================'
    call Log('I',message)

    do id = 1, History_id_count
       dtsec = real(History_vars(id)%dstep,kind=DP) * History_DTSEC

       write(message,'(A24,1x,A24,1x,I8,1x,F13.3,1x,I8,1x,L8,1x,A6)') History_vars(id)%item,     &
                                                                      History_vars(id)%outname,  &
                                                                      History_vars(id)%size,     &
                                                                      dtsec,                     &
                                                                      History_vars(id)%dstep,    &
                                                                      History_vars(id)%taverage, &
                                                                      History_vars(id)%zcoord
       call Log('I',message)
    enddo

    write(message,'(2A)') '=================================================', &
                          '================================================'
    call Log('I',message)
    call Log('I','')

    return
  end subroutine HistoryOutputList

  !-----------------------------------------------------------------------------
  subroutine HistoryFinalize
    use gtool_file, only: &
       FileDetachBuffer, &
       FileClose
    implicit none

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FileDetachBuffer( fid ) ! Release the internal buffer previously allowed to be used by PnetCDF
          call FileClose( fid )
          prev_fid = fid
       endif
    enddo

    return
  end subroutine HistoryFinalize

end module gtool_history



!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only:t
!End:
!
!++
