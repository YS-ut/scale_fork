!-------------------------------------------------------------------------------
!> module file_history
!!
!! @par Description
!!          I/O handling for history output
!!
!! @author Team SCALE
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from scale_file_history.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module scale_file_history
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
     Log,         &
     Log_nml,     &
     LOG_fid,     &
     LOG_fid_nml, &
     LOG_LMSG
  use scale_precision, only: &
     SP, &
     DP
  use scale_file, only: &
     FILE_HLONG, &
     FILE_HSHORT, &
     FILE_HMID
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FILE_HISTORY_Init
  public :: FILE_HISTORY_Check
  public :: FILE_HISTORY_Add_Variable
  public :: FILE_HISTORY_Create
  public :: FILE_HISTORY_Put_Axis
  public :: FILE_HISTORY_Put_Associated_Coordinates
  public :: FILE_HISTORY_Set_Global_Attribute
  public :: FILE_HISTORY_Set_Attribute
  public :: FILE_HISTORY_Set_Mapping
  public :: FILE_HISTORY_Query
  public :: FILE_HISTORY_Put
  public :: FILE_HISTORY_Write_All
  public :: FILE_HISTORY_Write_Axes
  public :: FILE_HISTORY_Write
  public :: FILE_HISTORY_Get
  public :: FILE_HISTORY_Output_List
  public :: FILE_HISTORY_Finalize

  interface FILE_HISTORY_Put_Axis
     module procedure FILE_HISTORY_Put_Axis_realSP
     module procedure FILE_HISTORY_Put_Axis_realDP
  end interface FILE_HISTORY_Put_Axis

  interface FILE_HISTORY_Put_Associated_Coordinates
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realSP_1D
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realDP_1D
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realSP_2D
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realDP_2D
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realSP_3D
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realDP_3D
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realSP_4D
     module procedure FILE_HISTORY_Put_Associated_Coordinates_realDP_4D
  end interface FILE_HISTORY_Put_Associated_Coordinates

  interface FILE_HISTORY_Set_Global_Attribute
     module procedure FILE_HISTORY_Set_Global_Attribute_Text
     module procedure FILE_HISTORY_Set_Global_Attribute_Int
     module procedure FILE_HISTORY_Set_Global_Attribute_Float
     module procedure FILE_HISTORY_Set_Global_Attribute_Double
  end interface FILE_HISTORY_Set_Global_Attribute

  interface FILE_HISTORY_Set_Attribute_
     module procedure FILE_HISTORY_Set_Attribute_Text
     module procedure FILE_HISTORY_Set_Attribute_Int
     module procedure FILE_HISTORY_Set_Attribute_Float
     module procedure FILE_HISTORY_Set_Attribute_Double
  end interface FILE_HISTORY_Set_Attribute

  interface FILE_HISTORY_Put
     module procedure FILE_HISTORY_Put_Id_realSP_0D
     module procedure FILE_HISTORY_Put_Id_realDP_0D
     module procedure FILE_HISTORY_Put_Id_realSP_1D
     module procedure FILE_HISTORY_Put_Id_realDP_1D
     module procedure FILE_HISTORY_Put_Id_realSP_2D
     module procedure FILE_HISTORY_Put_Id_realDP_2D
     module procedure FILE_HISTORY_Put_Id_realSP_3D
     module procedure FILE_HISTORY_Put_Id_realDP_3D
  end interface FILE_HISTORY_Put

  interface FILE_HISTORY_Get
     module procedure FILE_HISTORY_Get_realSP_1D
     module procedure FILE_HISTORY_Get_realDP_1D
     module procedure FILE_HISTORY_Get_realSP_2D
     module procedure FILE_HISTORY_Get_realDP_2D
     module procedure FILE_HISTORY_Get_realSP_3D
     module procedure FILE_HISTORY_Get_realDP_3D
  end interface FILE_HISTORY_Get

  type request
     character(len=File_HSHORT) :: item              !> Name of variable (in the code)
     character(len=File_HSHORT) :: outname           !> Name of variable (for output)
     character(len=File_HLONG)  :: basename          !> Base name of the file
     logical                    :: postfix_timelabel !> Add time label to basename?
     character(len=File_HMID)   :: zcoord            !> Z-coordinate
     integer                    :: dstep             !> Time unit
     logical                    :: taverage          !> Apply time average?
     integer                    :: dtype             !> Data type
     logical                    :: registered        !> This item is registered?
  end type request

  type vars
     character(len=FILE_HSHORT) :: item              !> Name of variable (in the code)
     character(len=FILE_HSHORT) :: outname           !> Name of variable (for output)
     character(len=FILE_HLONG)  :: basename          !> Base name of the file
     logical                    :: postfix_timelabel !> Add time label to basename?
     character(len=FILE_HMID)   :: zcoord            !> Z-coordinate
     integer                    :: dstep             !> Time unit
     logical                    :: taverage          !> Apply time average?
     integer                    :: dtype             !> Data type

     integer                    :: fid               !> FILE id of the file
     integer                    :: vid               !> Variable id
     character(len=FILE_HLONG)  :: desc              !> Variable description
     character(len=FILE_HSHORT) :: units             !> Variable units
     character(len=FILE_HSHORT) :: mapping           !> Map projection
     integer                    :: ndims             !> number of dimensions
     character(len=FILE_HSHORT) :: dims (4)          !> name of dimension
     integer                    :: start(4)          !> global subarray starting indices
     integer                    :: count(4)          !> global subarray request sizes

     integer                    :: waitstep          !> Step length to suppress output [step]
     integer                    :: laststep_write    !> Last step when the variable is written
     integer                    :: laststep_put      !> Last step when the variable is put
     logical                    :: flag_clear        !> Data buffer should be cleared at the timing of putting?
     integer                    :: size              !> Size of array
     real(DP)                   :: timesum           !> Buffer for time
     real(DP), pointer          :: varsum(:)         !> Buffer for value
  end type vars

  type axis
     character(len=FILE_HSHORT) :: name
     character(len=FILE_HLONG)  :: desc
     character(len=FILE_HSHORT) :: units
     character(len=FILE_HSHORT) :: dim
     integer                    :: dtype
     integer                    :: dim_size
     real(DP), pointer          :: var(:)
     logical                    :: down
     integer                    :: gdim_size  ! global dimension size
     integer                    :: start(1)   ! global array start index
  end type axis

  type assoc
     character(len=FILE_HSHORT) :: name
     character(len=FILE_HLONG)  :: desc
     character(len=FILE_HSHORT) :: units
     integer                    :: ndims
     character(len=FILE_HSHORT) :: dims(4)
     integer                    :: dtype
     real(DP), pointer          :: var(:)
     integer                    :: start(4)   ! global array start indices
     integer                    :: count(4)   ! global array request lengths
  end type assoc

  !-----------------------------------------------------------------------------
  !
  !++ included parameters
  !
  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !

  ! From upstream side of the library
  integer                    :: FILE_HISTORY_master      !> Number of master rank
  integer                    :: FILE_HISTORY_myrank      !> Number of my rank

  real(DP)                   :: FILE_HISTORY_STARTDAYSEC !> Start date [second]
  real(DP)                   :: FILE_HISTORY_DTSEC       !> Delta t    [second]
  character(len=FILE_HMID)   :: FILE_HISTORY_TIME_SINCE  !> Offset time

  ! From NAMELIST or upstream side of the library
  character(len=FILE_HMID)   :: FILE_HISTORY_TITLE                  !> Header information of the output file: title
  character(len=FILE_HMID)   :: FILE_HISTORY_SOURCE                 !> Header information of the output file: model name
  character(len=FILE_HMID)   :: FILE_HISTORY_INSTITUTION            !> Header information of the output file: institution
  character(len=FILE_HMID)   :: FILE_HISTORY_TIME_UNITS             !> Unit for time axis
  logical                    :: FILE_HISTORY_OUTPUT_STEP0 = .false. !> Output value at step=0?
  integer                    :: FILE_HISTORY_OUTPUT_WAIT_STEP       !> Step length to suppress output
  integer                    :: FILE_HISTORY_OUTPUT_SWITCH_STEP     !> Step interval to switch output file
  integer                    :: FILE_HISTORY_OUTPUT_SWITCH_LASTSTEP !> Last step when the file is switched
  logical                    :: FILE_HISTORY_ERROR_PUTMISS = .true. !> Abort if the value is never stored after last output?

  ! working
  integer,       parameter   :: FILE_HISTORY_req_limit = 1000 !> number limit for history item request
  integer                    :: FILE_HISTORY_req_count = 0    !> number of requested item
  type(request), allocatable :: FILE_HISTORY_req(:)

  integer,                   :: FILE_HISTORY_id_count = 0     !> number of registered item
  type(vars),    allocatable :: FILE_HISTORY_vars(:)
  logical,       allocatable :: FILE_HISTORY_axis_written(:)  !> Axis for this file is already written?

  integer,       parameter   :: FILE_HISTORY_axis_limit = 100              !> number limit of axes
  integer                    :: FILE_HISTORY_axis_count =   0
  type(axis)                 :: FILE_HISTORY_axis(FILE_HISTORY_axis_limit)

  integer,       parameter   :: FILE_HISTORY_assoc_limit = 20              !> number limit of associated coordinates
  integer                    :: FILE_HISTORY_assoc_count =  0
  type(assoc)                :: FILE_HISTORY_assoc(FILE_HISTORY_assoc_limit)

  integer                    :: laststep_write = -1
  logical                    :: firsttime      = .true.
  character(len=LOG_LMSG)    :: message        = ''
  logical                    :: debug          = .false.

  integer                    :: FILE_HISTORY_io_buffer_size !>  internal buffer for PnetCDF

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Init( &
       item_count,                &
       variant_count,             &
       isize,                     &
       jsize,                     &
       ksize,                     &
       master,                    &
       myrank,                    &
       title,                     &
       source,                    &
       institution,               &
       time_start,                &
       time_interval,             &
       time_units,                &
       time_since,                &
       default_basename,          &
       default_postfix_timelabel, &
       default_zcoord,            &
       default_tinterval,         &
       default_tunit,             &
       default_taverage,          &
       default_datatype,          &
       namelist_filename,         &
       namelist_fid               )
#if defined(PGI) || defined(SX)
    use dc_log, only: &
       LOG_master_nml
#endif
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8, &
       FILE_preclist
    use scale_calendar, only: &
       CALENDAR_unit2sec
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,          intent(out) :: item_count
    integer,          intent(out) :: variant_count
    integer,          intent(in)  :: isize
    integer,          intent(in)  :: jsize
    integer,          intent(in)  :: ksize
    integer,          intent(in)  :: master
    integer,          intent(in)  :: myrank
    character(len=*), intent(in)  :: title
    character(len=*), intent(in)  :: source
    character(len=*), intent(in)  :: institution
    real(DP),         intent(in)  :: time_start
    real(DP),         intent(in)  :: time_interval

    character(len=*), intent(in), optional :: time_units
    character(len=*), intent(in), optional :: time_since
    character(len=*), intent(in), optional :: default_basename
    logical,          intent(in), optional :: default_postfix_timelabel
    character(len=*), intent(in), optional :: default_zcoord
    real(DP),         intent(in), optional :: default_tinterval
    character(len=*), intent(in), optional :: default_tunit
    logical,          intent(in), optional :: default_taverage
    character(len=*), intent(in), optional :: default_datatype
    character(len=*), intent(in), optional :: namelist_filename
    integer         , intent(in), optional :: namelist_fid

    character(len=FILE_HLONG)  :: FILE_HISTORY_DEFAULT_BASENAME          !> Base name of the file
    logical                    :: FILE_HISTORY_DEFAULT_POSTFIX_TIMELABEL !> Add timelabel to the basename?
    character(len=FILE_HSHORT) :: FILE_HISTORY_DEFAULT_ZCOORD            !> Default z-coordinate
    real(DP)                   :: FILE_HISTORY_DEFAULT_TINTERVAL         !> Time interval
    character(len=FILE_HSHORT) :: FILE_HISTORY_DEFAULT_TUNIT             !> Time unit
    logical                    :: FILE_HISTORY_DEFAULT_TAVERAGE          !> Apply time average?
    character(len=FILE_HSHORT) :: FILE_HISTORY_DEFAULT_DATATYPE          !> Data type
                                                                         !> REAL4 : single precision
                                                                         !> REAL8 : double precision
    real(DP)                   :: FILE_HISTORY_OUTPUT_WAIT               !> Time length to suppress output
    character(len=FILE_HSHORT) :: FILE_HISTORY_OUTPUT_WAIT_TUNIT         !> Time unit
    real(DP)                   :: FILE_HISTORY_OUTPUT_SWITCH_TINTERVAL   !> Time interval to switch output file
    character(len=FILE_HSHORT) :: FILE_HISTORY_OUTPUT_SWITCH_TUNIT       !> Time unit

    NAMELIST / PARAM_FILE_HISTORY / &
       FILE_HISTORY_TITLE,                     &
       FILE_HISTORY_SOURCE,                    &
       FILE_HISTORY_INSTITUTION,               &
       FILE_HISTORY_TIME_UNITS,                &
       FILE_HISTORY_DEFAULT_BASENAME,          &
       FILE_HISTORY_DEFAULT_POSTFIX_TIMELABEL, &
       FILE_HISTORY_DEFAULT_ZCOORD,            &
       FILE_HISTORY_DEFAULT_TINTERVAL,         &
       FILE_HISTORY_DEFAULT_TUNIT,             &
       FILE_HISTORY_DEFAULT_TAVERAGE,          &
       FILE_HISTORY_DEFAULT_DATATYPE,          &
       FILE_HISTORY_OUTPUT_STEP0,              &
       FILE_HISTORY_OUTPUT_WAIT,               &
       FILE_HISTORY_OUTPUT_WAIT_TUNIT,         &
       FILE_HISTORY_OUTPUT_SWITCH_TINTERVAL,   &
       FILE_HISTORY_OUTPUT_SWITCH_TUNIT,       &
       FILE_HISTORY_ERROR_PUTMISS,             &
       debug

    character(len=FILE_HSHORT) :: ITEM              !> name of variable (in the code)
    character(len=FILE_HSHORT) :: OUTNAME           !> name of variable (for output)
    character(len=FILE_HLONG)  :: BASENAME          !> base name of the file
    logical                    :: POSTFIX_TIMELABEL !> Add timelabel to the basename?
    character(len=FILE_HSHORT) :: ZCOORD            !> z-coordinate
    real(DP)                   :: TINTERVAL         !> time interval
    character(len=FILE_HSHORT) :: TUNIT             !> time unit
    logical                    :: TAVERAGE          !> apply time average?
    character(len=FILE_HSHORT) :: DATATYPE          !> data type

    NAMELIST / HISTORY_ITEM / &
       ITEM,              &
       OUTNAME,           &
       BASENAME,          &
       POSTFIX_TIMELABEL, &
       ZCOORD,            &
       TINTERVAL,         &
       TUNIT,             &
       TAVERAGE,          &
       DATATYPE

    integer  :: array_size
    integer  :: reqid
    real(DP) :: dtsec
    integer  :: dstep

    integer                    :: id1, id2, count
    character(len=FILE_HSHORT) :: item1, item2

    integer  :: fid, ierr
    integer  :: n, id

    intrinsic size
    !---------------------------------------------------------------------------

    call Log('I','')
    call Log('I','###### Module[FILE_HISTORY] / Origin[scalelib]')

    ! setup
    FILE_HISTORY_master      = master
    FILE_HISTORY_myrank      = myrank

    FILE_HISTORY_STARTDAYSEC = time_start
    FILE_HISTORY_DTSEC       = time_interval
    if ( present(time_since) ) then
       FILE_HISTORY_TIME_SINCE = time_since
    else
       FILE_HISTORY_TIME_SINCE = ''
    endif

    FILE_HISTORY_TIME_UNITS                = 'seconds' !> Unit for time axis
    FILE_HISTORY_DEFAULT_BASENAME          = ''        !> Base name of the file
    FILE_HISTORY_DEFAULT_POSTFIX_TIMELABEL = .false.   !> Add timelabel to the basename?
    FILE_HISTORY_DEFAULT_ZCOORD            = ''        !> Default z-coordinate
    FILE_HISTORY_DEFAULT_TINTERVAL         = -1.0_DP   !> Time interval
    FILE_HISTORY_DEFAULT_TUNIT             = 'SEC'     !> Time unit
    FILE_HISTORY_DEFAULT_TAVERAGE          = .false.   !> Apply time average?
    FILE_HISTORY_DEFAULT_DATATYPE          = 'REAL4'   !> Data type
    FILE_HISTORY_OUTPUT_WAIT               =  0.0_DP   !> Time length to suppress output
    FILE_HISTORY_OUTPUT_WAIT_TUNIT         = 'SEC'     !> Time unit
    FILE_HISTORY_OUTPUT_SWITCH_TINTERVAL   = -1.0_DP   !> Time interval to switch output file
    FILE_HISTORY_OUTPUT_SWITCH_TUNIT       = 'SEC'     !> Time unit

    !--- read namelist
    FILE_HISTORY_TITLE       = title
    FILE_HISTORY_SOURCE      = source
    FILE_HISTORY_INSTITUTION = institution
    if( present(time_units)                ) FILE_HISTORY_TIME_UNITS                = time_units
    if( present(default_basename)          ) FILE_HISTORY_DEFAULT_BASENAME          = default_basename
    if( present(default_postfix_timelabel) ) FILE_HISTORY_DEFAULT_POSTFIX_TIMELABEL = default_postfix_timelabel
    if( present(default_zcoord)            ) FILE_HISTORY_DEFAULT_ZCOORD            = default_zcoord
    if( present(default_tinterval)         ) FILE_HISTORY_DEFAULT_TINTERVAL         = default_tinterval
    if( present(default_tunit)             ) FILE_HISTORY_DEFAULT_TUNIT             = default_tunit
    if( present(default_taverage)          ) FILE_HISTORY_DEFAULT_TAVERAGE          = default_taverage
    if( present(default_datatype)          ) FILE_HISTORY_DEFAULT_DATATYPE          = default_datatype

    fid = -1
    if ( present(namelist_fid) ) then
       fid = namelist_fid
    elseif( present(namelist_filename) ) then
       if ( namelist_filename /= '' ) then
          open( unit   = fid,                     &
                file   = trim(namelist_filename), &
                form   = 'formatted',             &
                status = 'old'                    )
       endif
    endif

    if ( fid <= 0 ) then
       call Log('E','xxx No namelist file is specified. Check!')
    endif

    rewind(fid)
    read(fid,nml=PARAM_FILE_HISTORY,iostat=ierr)
    if    ( ierr < 0 ) then !--- missing
       call Log('I','*** Not found namelist. Default used.')
    elseif( ierr > 0 ) then !--- fatal error
       call Log('E','xxx Not appropriate names in namelist PARAM_FILE_HISTORY. Check!')
    endif

#if defined(PGI) || defined(SX)
    if ( LOG_master_nml ) write(LOG_fid_nml,nml=PARAM_FILE_HISTORY)
#else
    write(message,nml=PARAM_FILE_HISTORY)
    call Log_nml('I',message)
#endif

    if ( FILE_HISTORY_OUTPUT_WAIT >= 0.0_DP ) then
       call CALENDAR_unit2sec( dtsec, FILE_HISTORY_OUTPUT_WAIT, FILE_HISTORY_OUTPUT_WAIT_TUNIT )
       FILE_HISTORY_OUTPUT_WAIT_STEP = int( dtsec / FILE_HISTORY_DTSEC )
    else
       write(message,*) 'xxx FILE_HISTORY_OUTPUT_WAIT must be positive. STOP'
       call Log('E',message)
    endif

    if ( FILE_HISTORY_OUTPUT_SWITCH_TINTERVAL >= 0.0_DP ) then
       call CALENDAR_unit2sec( dtsec, FILE_HISTORY_OUTPUT_SWITCH_TINTERVAL, FILE_HISTORY_OUTPUT_SWITCH_TUNIT )
       FILE_HISTORY_OUTPUT_SWITCH_STEP = int( dtsec / FILE_HISTORY_DTSEC )
    else
       FILE_HISTORY_OUTPUT_SWITCH_STEP = -1
    endif
    FILE_HISTORY_OUTPUT_SWITCH_LASTSTEP = 0

    array_size = isize * jsize * ksize

    ! count history request
    FILE_HISTORY_req_count = 0
    rewind(fid)
    do n = 1, FILE_HISTORY_req_limit
       ITEM      = ''
       OUTNAME   = 'undefined'
       BASENAME  = FILE_HISTORY_DEFAULT_BASENAME

       read(fid,nml=HISTITEM,iostat=ierr)
       if( ierr /= 0 ) exit
       if( BASENAME == '' .OR. ITEM == '' .OR. OUTNAME == '' ) cycle ! invalid HISTITEM

       FILE_HISTORY_req_count = FILE_HISTORY_req_count + 1
    enddo

    item_count    = FILE_HISTORY_req_count
    variant_count = 1

    if    ( FILE_HISTORY_req_count > FILE_HISTORY_req_limit ) then
       write(message,*) 'xxx request of history file is exceed! n >', FILE_HISTORY_req_limit
       call Log('E',message)
    elseif( FILE_HISTORY_req_count == 0 ) then
       call Log('I','*** No history file specified.')
       return
    endif

    allocate( FILE_HISTORY_req(FILE_HISTORY_req_count) )

    ! allows PnetCDF to use an internal buffer to aggregate write requests
    FILE_HISTORY_io_buffer_size = array_size * FILE_HISTORY_req_count * 8

    ! read history request
    reqid   = 0
    if ( fid > 0 ) rewind(fid)
    do n = 1, FILE_HISTORY_req_limit
       ! set default
       ITEM              = ''
       OUTNAME           = 'undefined'
       BASENAME          = FILE_HISTORY_DEFAULT_BASENAME
       POSTFIX_TIMELABEL = FILE_HISTORY_DEFAULT_POSTFIX_TIMELABEL
       ZCOORD            = FILE_HISTORY_DEFAULT_ZCOORD
       TINTERVAL         = FILE_HISTORY_DEFAULT_TINTERVAL
       TUNIT             = FILE_HISTORY_DEFAULT_TUNIT
       TAVERAGE          = FILE_HISTORY_DEFAULT_TAVERAGE
       DATATYPE          = FILE_HISTORY_DEFAULT_DATATYPE

       read(fid,nml=HISTORY_ITEM,iostat=ierr)
       if( ierr /= 0 ) exit
       if( BASENAME == '' .OR. ITEM == '' .OR. OUTNAME == '' ) cycle ! invalid HISTITEM

       if ( LOG_fid_nml /= LOG_fid ) then
#if defined(PGI) || defined(SX)
          if ( LOG_master_nml ) write(LOG_fid_nml,nml=HISTORY_ITEM)
#else
          write(message,nml=HISTORY_ITEM)
          call Log_nml('I',message)
#endif
       endif

       ! check duplicated request
       if ( OUTNAME == 'undefined' ) OUTNAME = ITEM ! set default name
       do id = 1, reqid
          if ( FILE_HISTORY_req(id)%outname == OUTNAME ) then
             write(message,*) &
             'xxx Same name of history output is already registered. Check!', trim(OUTNAME)
             call Log('E',message)
          endif
       enddo

       reqid = reqid + 1

       FILE_HISTORY_req(reqid)%item              = ITEM
       FILE_HISTORY_req(reqid)%outname           = OUTNAME
       FILE_HISTORY_req(reqid)%basename          = BASENAME
       FILE_HISTORY_req(reqid)%postfix_timelabel = POSTFIX_TIMELABEL
       if( FILE_HISTORY_OUTPUT_SWITCH_STEP >= 0 ) FILE_HISTORY_req(reqid)%postfix_timelabel = .true. ! force true
       FILE_HISTORY_req(reqid)%zcoord            = ZCOORD
       FILE_HISTORY_req(reqid)%taverage          = TAVERAGE

       call CALENDAR_unit2sec( dtsec, TINTERVAL, TUNIT )
       dstep = int( dtsec / FILE_HISTORY_DTSEC )

       if ( dtsec <= 0.D0 ) then
          write(message,*) &
          'xxx Not appropriate time interval. Check!', trim(ITEM), TINTERVAL, trim(TUNIT)
          call Log('E',message)
       endif

       if ( abs(dtsec-real(dstep,kind=DP)*FILE_HISTORY_DTSEC ) > eps ) then
          write(message,*) &
          'xxx time interval must be a multiple of delta t. (interval,dt)=', dtsec, FILE_HISTORY_DTSEC
          call Log('E',message)
       endif

       FILE_HISTORY_req(reqid)%dstep  = dstep

       if    ( DATATYPE == 'REAL4' ) then
          FILE_HISTORY_req(reqid)%dtype  = FILE_REAL4
       elseif( DATATYPE == 'REAL8' ) then
          FILE_HISTORY_req(reqid)%dtype  = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate DATATYPE. Check!', DATATYPE
          call Log('E',message)
       endif

       FILE_HISTORY_req(reqid)%registered = .false.
    enddo

    call Log('I','')
    write(message,'(A,I4)') '*** Number of requested history item             : ', FILE_HISTORY_req_count
    call Log('I',message)
    write(message,'(A,A)')  '*** Output default data type                     : ', FILE_HISTORY_DEFAULT_DATATYPE
    call Log('I',message)
    write(message,'(A,L4)') '*** Output value at the initial step?            : ', FILE_HISTORY_OUTPUT_STEP0
    call Log('I',message)
    if ( FILE_HISTORY_OUTPUT_WAIT_STEP > 0 ) then
       write(message,'(A,I8)') '*** Time when the output is suppressed [step]    : ', FILE_HISTORY_OUTPUT_WAIT_STEP
       call Log('I',message)
    endif
    if ( FILE_HISTORY_OUTPUT_SWITCH_STEP >= 0 ) then
       write(message,'(A,I8)') '*** Interval for switching the file [step]       : ', FILE_HISTORY_OUTPUT_SWITCH_STEP
       call Log('I',message)
    endif
    write(message,'(A,L4)') '*** Check if requested item is not registered?   : ', FILE_HISTORY_ERROR_PUTMISS
    call Log('I',message)

    if ( .NOT. present(namelist_fid) ) then
       if( fid > 0 ) close(fid)
    endif

    FILE_HISTORY_id_count = 0
    allocate( FILE_HISTORY_vars        (  FILE_HISTORY_req_count) )
    allocate( FILE_HISTORY_axis_written(0:FILE_HISTORY_req_count) )

    ! count number of items and variants
    do id1 = 1, item_count
       item1 = FILE_HISTORY_req(id1)%item
       count = 1
       do id2 = id1, item_count
          item2 = FILE_HISTORY_req(id2)%item
          if( item1 == item2 ) count = count + 1
       enddo
       variant_count = max( variant_count, count)
    enddo

    return
  end subroutine FILE_HISTORY_Init

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Check( &
       existed,   &
       item,      &
       zcoord     )
    implicit none

    logical,          intent(out)          :: existed
    character(len=*), intent(in)           :: item
    character(len=*), intent(in), optional :: zcoord

    integer :: max_count
    integer :: n
    !---------------------------------------------------------------------------

    existed = .false.

    max_count = min( FILE_HISTORY_id_count, FILE_HISTORY_req_count )

    !--- search existing item
    do n = 1, max_count
       if ( item == FILE_HISTORY_vars(n)%item ) then ! match (at least one) existing item
          !--- check z-coordinate
          if ( present(zcoord) ) then
             if ( FILE_HISTORY_vars(n)%zcoord == zcoord ) then
                existed = .true.
                return
             endif
          else
             existed = .true.
             return
          endif
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Check

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Add_Variable( &
       nregist,   &
       item,      &
       dims,      &
       desc,      &
       units,     &
       mapping,   &
       now_step,  &
       zcoord,    &
       start,     &
       count      )
    use scale_file, only: &
       FILE_dtypelist
    implicit none

    integer,           intent(out) :: nregist
    character(len=*),  intent(in)  :: item
    character(len=*),  intent(in)  :: dims(:)
    character(len=*),  intent(in)  :: desc
    character(len=*),  intent(in)  :: units
    character(len=*),  intent(in)  :: mapping
    integer,           intent(in)  :: now_step

    character(len=*),  intent(in), optional :: zcoord
    integer,           intent(in), optional :: start(:) ! global subarray starting indices of this process's write request
    integer,           intent(in), optional :: count(:) ! lengths of this process's write request along each dimension

    integer :: reqid, id
    integer :: ndims
    logical :: existed
    integer :: n

    intrinsic size
    !---------------------------------------------------------------------------

    nregist = 0

    call FILE_HISTORY_Check( existed, & ! [OUT]
                       item,    & ! [IN]
                       zcoord   ) ! [IN]

    if ( .NOT. existed ) then ! request-register matching check

       do reqid = 1, FILE_HISTORY_req_count

          ! note: plural requests are allowed for each item
          if ( item == FILE_HISTORY_req(reqid)%item ) then

             if ( present(zcoord) ) then
                if ( FILE_HISTORY_req(reqid)%zcoord /= zcoord ) cycle
             endif

             FILE_HISTORY_req(reqid)%registered = .true.

             existed = .true.
             nregist = nregist + 1

             FILE_HISTORY_id_count = FILE_HISTORY_id_count + 1
             id               = FILE_HISTORY_id_count

             FILE_HISTORY_vars(id)%item              = FILE_HISTORY_req(reqid)%item
             FILE_HISTORY_vars(id)%outname           = FILE_HISTORY_req(reqid)%outname
             FILE_HISTORY_vars(id)%basename          = FILE_HISTORY_req(reqid)%basename
             FILE_HISTORY_vars(id)%postfix_timelabel = FILE_HISTORY_req(reqid)%postfix_timelabel
             FILE_HISTORY_vars(id)%zcoord            = FILE_HISTORY_req(reqid)%zcoord
             FILE_HISTORY_vars(id)%dstep             = FILE_HISTORY_req(reqid)%dstep
             FILE_HISTORY_vars(id)%taverage          = FILE_HISTORY_req(reqid)%taverage
             FILE_HISTORY_vars(id)%dtype             = FILE_HISTORY_req(reqid)%dtype

             FILE_HISTORY_vars(id)%fid               = -1
             FILE_HISTORY_vars(id)%vid               = -1
             FILE_HISTORY_vars(id)%desc              = desc
             FILE_HISTORY_vars(id)%units             = units
             FILE_HISTORY_vars(id)%mapping           = mapping

             ! history variable has been reshaped to 1D, we preserve the
             ! original shape in count(:) and FILE_HISTORY_count(:,id)
             ! FILE_HISTORY_ndims(id) stores number of dimensions of original shape
             ndims = size(dims)

             FILE_HISTORY_vars(id)%ndims             = ndims
             FILE_HISTORY_vars(id)%dims (1:ndims)    = dims(1:ndims)
             FILE_HISTORY_vars(id)%start(:)          = 1
             FILE_HISTORY_vars(id)%count(:)          = 1
             if ( present(start) ) FILE_HISTORY_vars(id)%start(:) = start(:)
             if ( present(count) ) FILE_HISTORY_vars(id)%count(:) = count(:)

             FILE_HISTORY_vars(id)%waitstep          = FILE_HISTORY_OUTPUT_WAIT_STEP
             if ( FILE_HISTORY_OUTPUT_STEP0 .AND. now_step == 1 ) then
                FILE_HISTORY_vars(id)%laststep_write = 1 - FILE_HISTORY_vars(id)%dstep
             else
                FILE_HISTORY_vars(id)%laststep_write = 1
             endif
             FILE_HISTORY_vars(id)%laststep_put      = FILE_HISTORY_vars(id)%laststep_write
             FILE_HISTORY_vars(id)%flag_clear        = .true.
             FILE_HISTORY_vars(id)%size              = -1

             FILE_HISTORY_vars(id)%timesum           = 0.0_DP

             if ( debug ) then
                write(message,*) '*** [HISTORY] Item registration No.= ', id
                call Log('I',message)
                write(message,*) '] Item name                      : ', trim(FILE_HISTORY_vars(id)%item)
                call Log('I',message)
                write(message,*) '] Output name                    : ', trim(FILE_HISTORY_vars(id)%outname)
                call Log('I',message)
                write(message,*) '] Description                    : ', trim(FILE_HISTORY_vars(id)%desc)
                call Log('I',message)
                write(message,*) '] Unit                           : ', trim(FILE_HISTORY_vars(id)%units)
                call Log('I',message)
                write(message,*) '] Basename of output file        : ', trim(FILE_HISTORY_vars(id)%basename)
                call Log('I',message)
                write(message,*) '] Add timelabel to the filename? : ', FILE_HISTORY_vars(id)%postfix_timelabel
                call Log('I',message)
                write(message,*) '] Z-coordinate                   : ', trim(FILE_HISTORY_vars(id)%zcoord)
                call Log('I',message)
                write(message,*) '] Interval [step]                : ', FILE_HISTORY_vars(id)%dstep
                call Log('I',message)
                write(message,*) '] Time Average?                  : ', FILE_HISTORY_vars(id)%taverage
                call Log('I',message)
                write(message,*) '] Datatype                       : ', trim(FILE_dtypelist(FILE_HISTORY_vars(id)%dtype))
                call Log('I',message)
                write(message,*) '] axis name                      : ', ( trim(FILE_HISTORY_vars(id)%dims(n))//" ", n=1, ndims )
                call Log('I',message)
                call Log('I','')
             endif

          endif ! match item?

       enddo

    endif ! new items?

    return
  end subroutine FILE_HISTORY_Add_Variable

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Create( &
       id,        &
       now_step,  &
       timelabel, &
       options,   &
       comm,      &
       existed    )
    use mpi, only: &
       MPI_COMM_NULL
    use scale_file, only: &
       FILE_Create,                   &
       FILE_Set_Option,                &
       FILE_Def_Axis,                  &
       FILE_Def_Associated_Coordinates, &
       FILE_Attach_Buffer,             &
       FILE_Add_Variable,              &
       FILE_Set_Attribute
    implicit none

    integer,           intent(in)  :: id
    integer,           intent(in)  :: now_step
    character(len=*),  intent(in)  :: timelabel

    character(len=*),  intent(in),  optional :: options ! 'filetype1:key1=val1&filetype2:key2=val2&...'
    integer,           intent(in),  optional :: comm    ! MPI communicator
    logical,           intent(out), optional :: existed

    logical                   :: shared_file_io
    character(len=FILE_HMID)  :: tunits
    character(len=FILE_HLONG) :: basename_mod
    logical                   :: fileexisted
    integer                   :: dim_size
    integer                   :: ndims
    real(DP)                  :: dtsec

    integer :: ic, ie, is, lo
    integer :: m
    !---------------------------------------------------------------------------

    if ( present(existed) ) existed = .true.

    if ( FILE_HISTORY_vars(id)%fid < 0 ) then ! time to create file

       ! check whether shared-file I/O method is enabled
       shared_file_io = .false.
       if ( present(comm) .AND. comm .NE. MPI_COMM_NULL ) shared_file_io = .true.

       if ( FILE_HISTORY_TIME_SINCE == '' ) then
          tunits = trim(FILE_HISTORY_TIME_UNITS)
       else
          tunits = trim(FILE_HISTORY_TIME_UNITS)//' since '//trim(FILE_HISTORY_TIME_SINCE)
       endif

       if ( FILE_HISTORY_vars(id)%postfix_timelabel ) then
          basename_mod = trim(FILE_HISTORY_vars(id)%basename)//'_'//trim(timelabel)
       else
          basename_mod = trim(FILE_HISTORY_vars(id)%basename)
       endif

       call FILE_Create( FILE_HISTORY_vars(id)%fid, & ! [OUT]
                         fileexisted,               & ! [OUT]
                         basename_mod,              & ! [IN]
                         FILE_HISTORY_TITLE,        & ! [IN]
                         FILE_HISTORY_SOURCE,       & ! [IN]
                         FILE_HISTORY_INSTITUTION,  & ! [IN]
                         FILE_HISTORY_master,       & ! [IN]
                         FILE_HISTORY_myrank,       & ! [IN]
                         time_units = tunits,       & ! [IN]
                         comm       = comm          ) ! [IN]

       if ( .NOT. fileexisted ) then ! new file

          ! write options
          if ( present(options) ) then
             ic = -1 ! index of ':'
             ie = -1 ! index of '='
             is =  1 ! start index
             lo = len_trim(options)
             do m = 1, lo+1
                if ( m == lo+1 .OR. options(m:m) == '&' ) then
                   if ( ic == -1 .OR. ie == -1 ) then
                      call Log('E','xxx option is invalid: '//trim(options))
                   endif

                   call FILE_Set_Option( FILE_HISTORY_vars(id)%fid, & ! [IN]
                                         options(is  :ic-1),        & ! [IN]
                                         options(ic+1:ie-1),        & ! [IN]
                                         options(ie+1:m -1)         ) ! [IN]
                   ic = -1
                   ie = -1
                   is = m+1
                elseif( options(m:m) == ':' ) then
                   ic = m
                elseif( options(m:m) == '=' ) then
                   ie = m
                endif
             enddo
          endif

          ! define registered history axis variables in the newly created file
          ! actual writing axis variables are deferred to FILE_HISTORY_WriteAxes
          do m = 1, FILE_HISTORY_axis_count
             if ( shared_file_io ) then ! for shared-file I/O, define axis in its global size
                dim_size = FILE_HISTORY_axis(m)%gdim_size ! axis global size
             else
                dim_size = FILE_HISTORY_axis(m)%dim_size
             endif

             call FILE_Def_Axis( FILE_HISTORY_vars(id)%fid,  & ! [IN]
                                 FILE_HISTORY_axis(m)%name,  & ! [IN]
                                 FILE_HISTORY_axis(m)%desc,  & ! [IN]
                                 FILE_HISTORY_axis(m)%units, & ! [IN]
                                 FILE_HISTORY_axis(m)%dim,   & ! [IN]
                                 FILE_HISTORY_axis(m)%dtype, & ! [IN]
                                 dim_size                   ) ! [IN]

             if ( FILE_HISTORY_axis(m)%down ) then
                call FILE_Set_Attribute( FILE_HISTORY_vars(id)%fid, FILE_HISTORY_axis(m)%name, 'positive', 'down' ) ! [IN]
             endif
          enddo

          ! define registered history associated coordinate variables in the newly created file
          ! actual writing coordinate variables are deferred to FILE_HISTORY_WriteAxes
          do m = 1, FILE_HISTORY_assoc_count
             ndims = FILE_HISTORY_assoc(m)%ndims

             call FILE_Def_Associated_Coordinates( FILE_HISTORY_vars(id)%fid,           & ! [IN]
                                                   FILE_HISTORY_assoc(m)%name,          & ! [IN]
                                                   FILE_HISTORY_assoc(m)%desc,          & ! [IN]
                                                   FILE_HISTORY_assoc(m)%units,         & ! [IN]
                                                   FILE_HISTORY_assoc(m)%dims(1:ndims), & ! [IN]
                                                   FILE_HISTORY_assoc(m)%dtype          ) ! [IN]
          enddo

          ! allows PnetCDF to allocate an internal buffer of size io_buffer_size
          ! to aggregate write requests for history variables
          call FILE_Attach_Buffer( FILE_HISTORY_vars(id)%fid, FILE_HISTORY_io_buffer_size ) ! [IN]

          FILE_HISTORY_axis_written(FILE_HISTORY_vars(id)%fid) = .false.

          if ( present(existed) ) existed = .false.

       endif ! new file?

    endif

    if ( FILE_HISTORY_vars(id)%vid < 0 ) then ! time to add
       ! Add new variable
       ndims = FILE_HISTORY_vars(id)%ndims

       dtsec = real(FILE_HISTORY_vars(id)%dstep,kind=DP) * FILE_HISTORY_DTSEC

       call FILE_Add_Variable( FILE_HISTORY_vars(id)%vid,           & ! [OUT]
                               FILE_HISTORY_vars(id)%fid,           & ! [IN]
                               FILE_HISTORY_vars(id)%outname,       & ! [IN]
                               FILE_HISTORY_vars(id)%desc,          & ! [IN]
                               FILE_HISTORY_vars(id)%units,         & ! [IN]
                               FILE_HISTORY_vars(id)%dims(1:ndims), & ! [IN]
                               FILE_HISTORY_vars(id)%dtype,         & ! [IN]
                               dtsec,                               & ! [IN]
                               FILE_HISTORY_vars(id)%taverage       ) ! [IN]


       if ( FILE_HISTORY_vars(id)%mapping /= "" ) then
          call FILE_Set_Attribute( FILE_HISTORY_vars(id)%fid,     &
                                 FILE_HISTORY_vars(id)%outname, &
                                 'grid_mapping',           &
                                 FILE_HISTORY_vars(id)%mapping  )
       endif
    endif

    return
  end subroutine FILE_HISTORY_Create

  !-----------------------------------------------------------------------------
  ! interface FILE_HISTORY_Put_Axis
  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Axis_realSP( &
       name,     &
       desc,     &
       units,    &
       dim,      &
       var,      &
       datatype, &
       down,     &
       gsize,    &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(SP),         intent(in) :: var(:)

    character(len=*), intent(in), optional :: datatype
    logical,          intent(in), optional :: down
    integer,          intent(in), optional :: gsize ! global dim size
    integer,          intent(in), optional :: start ! global subarray start indices

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL4
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_axis_count < FILE_HISTORY_axis_limit ) then
       FILE_HISTORY_axis_count = FILE_HISTORY_axis_count + 1
       id                 = FILE_HISTORY_axis_count

       allocate( FILE_HISTORY_axis(id)%var(dim_size) )

       FILE_HISTORY_axis(id)%name     = name
       FILE_HISTORY_axis(id)%desc     = desc
       FILE_HISTORY_axis(id)%units    = units
       FILE_HISTORY_axis(id)%dim      = dim
       FILE_HISTORY_axis(id)%dtype    = dtype
       FILE_HISTORY_axis(id)%dim_size = dim_size
       FILE_HISTORY_axis(id)%var(:)   = real(var(:),kind=DP)

       if ( present(down) ) then
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%down = down
       else
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%down = .false.
       endif
       if ( present(gsize) ) &  ! global dimension size
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%gdim_size = gsize
       if ( present(start) ) then  ! global subarray starting indices
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%start(1) = start
       else
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%start(1) = 1
       end if
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Axis_realSP

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Axis_realDP( &
       name,     &
       desc,     &
       units,    &
       dim,      &
       var,      &
       datatype, &
       down,     &
       gsize,    &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(DP),         intent(in) :: var(:)

    character(len=*), intent(in), optional :: datatype
    logical,          intent(in), optional :: down
    integer,          intent(in), optional :: gsize ! global dim size
    integer,          intent(in), optional :: start ! global subarray start indices

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL8
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_axis_count < FILE_HISTORY_axis_limit ) then
       FILE_HISTORY_axis_count = FILE_HISTORY_axis_count + 1
       id                 = FILE_HISTORY_axis_count

       allocate( FILE_HISTORY_axis(id)%var(dim_size) )

       FILE_HISTORY_axis(id)%name     = name
       FILE_HISTORY_axis(id)%desc     = desc
       FILE_HISTORY_axis(id)%units    = units
       FILE_HISTORY_axis(id)%dim      = dim
       FILE_HISTORY_axis(id)%dtype    = dtype
       FILE_HISTORY_axis(id)%dim_size = dim_size
       FILE_HISTORY_axis(id)%var(:)   = real(var(:),kind=DP)

       if ( present(down) ) then
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%down = down
       else
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%down = .false.
       endif
       if ( present(gsize) ) &  ! global dimension size
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%gdim_size = gsize
       if ( present(start) ) then  ! global subarray starting indices
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%start(1) = start
       else
          FILE_HISTORY_axis(FILE_HISTORY_axis_count)%start(1) = 1
       end if
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Axis_realDP

  !-----------------------------------------------------------------------------
  ! interface FILE_HISTORY_PutAssociatedCoordinates
  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_1D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL4
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 1
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:1) = dims(1:1)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:1) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:1) = start(1:1)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_1D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_1D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL8
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 1
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:1) = dims(1:1)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:1) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:1) = start(1:1)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_1D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_2D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL4
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 2
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:2) = dims(1:2)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:2) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:2) = start(1:2)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_2D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_2D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL8
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 2
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:2) = dims(1:2)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:2) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:2) = start(1:2)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_2D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_3D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL4
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 3
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:3) = dims(1:3)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:3) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:3) = start(1:3)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_3D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_3D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL8
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 3
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:3) = dims(1:3)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:3) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:3) = start(1:3)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_3D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_4D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL4
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 4
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:4) = dims(1:4)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:4) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:4) = start(1:4)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realSP_4D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_4D( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use scale_file, only: &
       FILE_REAL4, &
       FILE_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:,:,:)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = FILE_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = FILE_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = FILE_REAL8
    endif

    dim_size = size(var)

    if ( FILE_HISTORY_assoc_count < FILE_HISTORY_assoc_limit ) then
       FILE_HISTORY_assoc_count = FILE_HISTORY_assoc_count + 1
       id                  = FILE_HISTORY_assoc_count

       allocate( FILE_HISTORY_assoc(id)%var(dim_size) )

       FILE_HISTORY_assoc(id)%name      = name
       FILE_HISTORY_assoc(id)%desc      = desc
       FILE_HISTORY_assoc(id)%units     = units
       FILE_HISTORY_assoc(id)%ndims     = 4
       FILE_HISTORY_assoc(id)%dims(:)   = ''
       FILE_HISTORY_assoc(id)%dims(1:4) = dims(1:4)
       FILE_HISTORY_assoc(id)%dtype     = dtype
       FILE_HISTORY_assoc(id)%var(:)    = real(reshape( var, (/ dim_size /) ),kind=DP)

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to preserve its original shape in count
       FILE_HISTORY_assoc(id)%count(1:4) = shape(var)
       if ( present(start) ) then
          FILE_HISTORY_assoc(id)%start(1:4) = start(1:4)
       else
          FILE_HISTORY_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine FILE_HISTORY_Put_Associated_Coordinates_realDP_4D

  !-----------------------------------------------------------------------------
  ! interface FILE_HISTORY_Set_Global_Attribute
  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Global_Attribute_Text( &
       key, &
       val  )
    use scale_file, only: &
       FILE_Set_Global_Attribute
    implicit none

    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Global_Attribute( fid, key, val ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Global_Attribute_Text

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Global_Attribute_Int( &
       key, &
       val  )
    use scale_file, only: &
       FILE_Set_Global_Attribute
    implicit none

    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Global_Attribute( fid, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Global_Attribute_Int

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Global_Attribute_float( &
       key, &
       val  )
    use scale_file, only: &
       FILE_Set_Global_Attribute
    implicit none

    character(len=*), intent(in) :: key
    real(SP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Global_Attribute( fid, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Global_Attribute_float

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Global_Attribute_double( &
       key, &
       val  )
    use scale_file, only: &
       FILE_Set_Global_Attribute
    implicit none

    character(len=*), intent(in) :: key
    real(DP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Global_Attribute( fid, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Global_Attribute_double

  !-----------------------------------------------------------------------------
  ! interface FILE_HISTORY_Set_Attribute
  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Attribute_Text( &
       varname, &
       key,     &
       val      )
    use scale_file, only: &
       FILE_Set_Attribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Attribute( fid, varname, key, val ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Attribute_Text

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Attribute_Int( &
       varname, &
       key,     &
       val      )
    use scale_file, only: &
       FILE_Set_Attribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Attribute( fid, varname, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Attribute_Int

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Attribute_Float( &
       varname, &
       key,     &
       val      )
    use scale_file, only: &
       FILE_Set_Attribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    real(SP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Attribute( fid, varname, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Attribute_Float

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Attribute_Double( &
       varname, &
       key,     &
       val      )
    use scale_file, only: &
       FILE_Set_Attribute
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    real(DP),         intent(in) :: val(:)

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Set_Attribute( fid, varname, key, val(:) ) ! [IN]
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Attribute_Double

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Set_Mapping( &
       mapping )
    use scale_file, only: &
       FILE_Add_Associated_Variable, &
       FILE_Set_Attribute
    implicit none

    character(len=*), intent(in) :: mapping

    logical :: existed
    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Add_Associated_Variable( fid,     & ! [IN]
                                             mapping, & ! [IN]
                                             existed  ) ! [OUT]

          if ( .NOT. existed ) then
             call FILE_Set_Attribute( fid, mapping, "grid_mapping_name", mapping ) ! [IN]
          endif

          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Set_Mapping

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Query( &
       item,     &
       step_now, &
       answer    )
    implicit none

    character(len=*), intent(in)  :: item
    integer,          intent(in)  :: step_now
    logical,          intent(out) :: answer

    integer :: id
    !---------------------------------------------------------------------------

    answer  = .false.

    ! note: multiple put may be necessary for the item
    do id = 1, FILE_HISTORY_id_count
       if ( item == FILE_HISTORY_vars(id)%item ) then
          if    ( FILE_HISTORY_vars(id)%taverage ) then
             answer = .true.
          elseif( step_now >= FILE_HISTORY_vars(id)%laststep_write + FILE_HISTORY_vars(id)%dstep ) then
             answer = .true.
          endif
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Query

  !-----------------------------------------------------------------------------
  ! interface FILE_HISTORY_Put
  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realSP_0D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var

    real(DP) :: dt
    integer  :: idx

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif


    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = 1
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
          idx = 1
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var * dt

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
          idx = 1
          FILE_HISTORY_vars(id)%varsum(idx) = real(var,kind=DP)

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realSP_0D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realDP_0D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var

    real(DP) :: dt
    integer  :: idx

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif


    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = 1
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
          idx = 1
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var * dt

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
          idx = 1
          FILE_HISTORY_vars(id)%varsum(idx) = real(var,kind=DP)

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realDP_0D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realSP_1D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var(:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(1)
    integer  :: i

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = vsize(1)
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
       do i = 1, vsize(1)
          idx = i
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var(i) * dt
       enddo

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
       do i = 1, vsize(1)
          idx = i
          FILE_HISTORY_vars(id)%varsum(idx) = real(var(i),kind=DP)
       enddo

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realSP_1D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realDP_1D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var(:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(1)
    integer  :: i

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = vsize(1)
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
       do i = 1, vsize(1)
          idx = i
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var(i) * dt
       enddo

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
       do i = 1, vsize(1)
          idx = i
          FILE_HISTORY_vars(id)%varsum(idx) = real(var(i),kind=DP)
       enddo

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realDP_1D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realSP_2D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var(:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(2)
    integer  :: i, j

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = vsize(1) * vsize(2)
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var(i,j) * dt
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = real(var(i,j),kind=DP)
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realSP_2D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realDP_2D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var(:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(2)
    integer  :: i, j

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = vsize(1) * vsize(2)
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var(i,j) * dt
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = (j-1)*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = real(var(i,j),kind=DP)
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realDP_2D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realSP_3D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(SP), intent(in) :: var(:,:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(3)
    integer  :: i, j, k

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = vsize(1) * vsize(2) * vsize(3)
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var(i,j,k) * dt
       enddo
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = real(var(i,j,k),kind=DP)
       enddo
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realSP_3D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Put_Id_realDP_3D( &
       id,       &
       step_now, &
       var       )
    use scale_const, only: &
       EPS => CONST_EPS
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(DP), intent(in) :: var(:,:,:)

    real(DP) :: dt
    integer  :: idx
    integer  :: vsize(3)
    integer  :: i, j, k

    intrinsic shape
    !---------------------------------------------------------------------------

    if( id < 0 ) return

    dt = ( step_now - FILE_HISTORY_vars(id)%laststep_put ) * FILE_HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. FILE_HISTORY_vars(id)%taverage ) ) then
       write(message,*) 'xxx FILE_HISTORY_ variable was put two times before output!: ', &
                        trim(FILE_HISTORY_vars(id)%item), step_now, FILE_HISTORY_vars(id)%laststep_put
       call Log('E',message)
    endif

    vsize = shape(var)

    if ( FILE_HISTORY_vars(id)%size == -1 ) then
       FILE_HISTORY_vars(id)%size = vsize(1) * vsize(2) * vsize(3)
       allocate( FILE_HISTORY_vars(id)%varsum( FILE_HISTORY_vars(id)%size ) )
    end if

    if ( FILE_HISTORY_vars(id)%flag_clear ) then ! time to purge
       FILE_HISTORY_vars(id)%timesum    = 0.0_DP
       if ( FILE_HISTORY_vars(id)%taverage ) FILE_HISTORY_vars(id)%varsum(:)  = 0.0_DP
    endif

    if ( FILE_HISTORY_vars(id)%taverage ) then
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = FILE_HISTORY_vars(id)%varsum(idx) + var(i,j,k) * dt
       enddo
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = FILE_HISTORY_vars(id)%timesum + dt
    else
       do k = 1, vsize(3)
       do j = 1, vsize(2)
       do i = 1, vsize(1)
          idx = ((k-1)*vsize(2)+(j-1))*vsize(1)+i
          FILE_HISTORY_vars(id)%varsum(idx) = real(var(i,j,k),kind=DP)
       enddo
       enddo
       enddo

       FILE_HISTORY_vars(id)%timesum = 0.0_DP
    endif

    FILE_HISTORY_vars(id)%laststep_put = step_now
    FILE_HISTORY_vars(id)%flag_clear   = .false.

    return
  end subroutine FILE_HISTORY_Put_Id_realDP_3D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Write_All( &
       step_now )
    use scale_file, only: &
       FILE_Flush
    implicit none
    integer, intent(in) :: step_now

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    ! Write registered history variables to history file
    do id = 1, FILE_HISTORY_id_count
       call FILE_HISTORY_Write( id,      & ! [IN]
                          step_now ) ! [IN]
    enddo

    ! when using PnetCDF, the above FILE_HISTORY_Write() only posts write requests
    ! Now we need to commit the requests to the file
    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Flush( fid )
          prev_fid = fid
       endif
    enddo

    ! check time to switching output file
    if (       FILE_HISTORY_OUTPUT_SWITCH_STEP >= 0                                      &
         .AND. step_now-FILE_HISTORY_OUTPUT_SWITCH_LASTSTEP > FILE_HISTORY_OUTPUT_SWITCH_STEP ) then

       call FILE_HISTORY_Finalize

       write(message,'(A)') '*** FILE_HISTORY_ file is switched.'
       call Log('I',message)

       do id = 1, FILE_HISTORY_id_count
          FILE_HISTORY_vars(id)%fid = -1 ! reset
          FILE_HISTORY_vars(id)%vid = -1 ! reset
       enddo

       FILE_HISTORY_OUTPUT_SWITCH_LASTSTEP = step_now-1
    endif

    return
  end subroutine FILE_HISTORY_Write_All

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Write_Axes( &
       axis_written_first )
    use scale_file, only: &
       FILE_End_Def,    &
       FILE_Flush,     &
       FILE_Write_Axis, &
       FILE_Write_Associated_Coordinates
    implicit none

    logical, intent(out) :: axis_written_first

    integer :: start(1)
    integer :: m, id, fid
    !---------------------------------------------------------------------------

    axis_written_first = .false.

    if( FILE_HISTORY_req_count  == 0 ) return
    if( FILE_HISTORY_axis_count == 0 ) return

    do id = 1, FILE_HISTORY_id_count

       fid = FILE_HISTORY_vars(id)%fid

       if( fid < 0 .OR. FILE_HISTORY_axis_written(fid) ) cycle

       call FILEEndDef( fid )

       ! write registered history variables to file
       do m = 1, FILE_HISTORY_axis_count
          if ( FILE_HISTORY_axis(m)%start(1) > 0 ) then
             start(1) = FILE_HISTORY_axis(m)%start(1)

             call FILE_Write_Axis( fid     ,                  & ! [IN]
                                   FILE_HISTORY_axis(m)%name, & ! [IN]
                                   FILE_HISTORY_axis(m)%var,  & ! [IN]
                                   start                      ) ! [IN]
          endif
       enddo

       do m = 1, FILE_HISTORY_assoc_count
          call FILE_Write_Associated_Coordinates( fid,                         & ! [IN]
                                                  FILE_HISTORY_assoc(m)%name,  & ! [IN]
                                                  FILE_HISTORY_assoc(m)%var,   & ! [IN]
                                                  FILE_HISTORY_assoc(m)%start, & ! [IN]
                                                  FILE_HISTORY_assoc(m)%count, & ! [IN]
                                                  FILE_HISTORY_assoc(m)%ndims  ) ! [IN]
       enddo

       ! for PnetCDF I/O, flush all pending nonblocking write requests
       call FILE_Flush( fid )

       ! mark the axes have been written
       FILE_HISTORY_axis_written(fid) = .true.
       axis_written_first        = .true.

    enddo

    return
  end subroutine FILE_HISTORY_Write_Axes

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Write( &
       id,  &
       step_now )
    use scale_calendar, only: &
       CALENDAR_sec2unit
    use scale_file, only: &
       FILEWrite
    implicit none

    integer, intent(in) :: id
    integer, intent(in) :: step_now

    integer  :: isize
    real(DP) :: time_str, time_end
    real(DP) :: sec_str,  sec_end
    !---------------------------------------------------------------------------

    if( FILE_HISTORY_req_count == 0 ) return

    if ( step_now < FILE_HISTORY_vars(id)%laststep_write + FILE_HISTORY_vars(id)%dstep ) then
       return
    endif

    if ( FILE_HISTORY_vars(id)%flag_clear ) then
       if ( FILE_HISTORY_ERROR_PUTMISS ) then
          write(message,'(3A)') 'xxx The time interval of history output ', trim(FILE_HISTORY_vars(id)%item), &
                                ' and the time interval of its related scheme are inconsistent.'
          call Log('I',message)
          write(message,'(A)')  'xxx Please check the namelist PARAM_TIME, PARAM_HISTORY, and HISTITEM.'
          call Log('I',message)
          write(message,'(2A)') 'xxx Please set FILE_HISTORY_ERROR_PUTMISS in the namelist PARAM_HISTORY to .false.', &
                                ' when you want to disable this check.'
          call Log('I',message)

          write(message,'(4A)') 'xxx The time interval of history output ', trim(FILE_HISTORY_vars(id)%item), &
                                ' and the time interval of its related scheme are inconsistent.',        &
                                ' Please see detail in log file.'
          call Log('E',message)
       else
          write(message,'(2A)') '*** Output value is not updated in this step. NAME : ', &
                                trim(FILE_HISTORY_vars(id)%item)
          call Log('I',message)
       endif
    endif

    isize = FILE_HISTORY_vars(id)%size

    if ( .NOT. FILE_HISTORY_vars(id)%flag_clear .AND. FILE_HISTORY_vars(id)%taverage ) then
       FILE_HISTORY_vars(id)%varsum(1:isize) = FILE_HISTORY_vars(id)%varsum(1:isize) / FILE_HISTORY_vars(id)%timesum
    endif

    if ( firsttime ) then
       firsttime = .false.
       call FILE_HISTORY_Output_List
    endif

    if ( step_now > FILE_HISTORY_vars(id)%waitstep ) then
       if ( laststep_write < step_now ) then ! log only once in this step
          write(message,'(A)') '*** Output FILE_HISTORY_'
          call Log('I',message)
       endif

       sec_str = FILE_HISTORY_STARTDAYSEC + real(FILE_HISTORY_vars(id)%laststep_write-1,kind=DP) * FILE_HISTORY_DTSEC
       sec_end = FILE_HISTORY_STARTDAYSEC + real(step_now                       -1,kind=DP) * FILE_HISTORY_DTSEC

       ! convert time units [sec]->[sec,min,hour,day,month,year]
       call CALENDAR_sec2unit( time_str, sec_str, FILE_HISTORY_TIME_UNITS )
       call CALENDAR_sec2unit( time_end, sec_end, FILE_HISTORY_TIME_UNITS )

       if ( FILE_HISTORY_vars(id)%count(1) > 0 ) then

          ! for one-file-per-process I/O method, FILE_HISTORY_vars(:)%count(1) == 1 always
          ! for one file shared by all processes, FILE_HISTORY_vars(:)%count(1) >= 0,
          ! being 0 indicates a 1D history variable, which will only be written by the
          ! south-most processes in parallel, or a z axis to be written by rank 0 only
          call FILE_Write( FILE_HISTORY_vars(id)%fid,             & ! [IN]
                           FILE_HISTORY_vars(id)%vid,             & ! [IN]
                           FILE_HISTORY_vars(id)%varsum(1:isize), & ! [IN]
                           time_str,                              & ! [IN]
                           time_end,                              & ! [IN]
                           FILE_HISTORY_vars(id)%start,           & ! global subarray start indices
                           FILE_HISTORY_vars(id)%count,           & ! global subarray lengths
                           FILE_HISTORY_vars(id)%ndims            ) ! ndims before reshape
       end if
    else
       if ( laststep_write < step_now ) then
          write(message,'(A)') '*** Output FILE_HISTORY_: Suppressed.'
          call Log('I',message)
       endif
    endif

    FILE_HISTORY_vars(id)%laststep_write = step_now
    FILE_HISTORY_vars(id)%flag_clear     = .true.

    laststep_write = step_now ! remember for multiple call in the same step

    return
  end subroutine FILE_HISTORY_Write

  !-----------------------------------------------------------------------------
  ! interface FILE_HISTORY_Get
  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Get_realDP_1D( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use scale_file, only: &
       FILE_Read
    implicit none

    real(DP),         intent(out) :: var(:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FILE_Read( var,                  & ! [OUT]
                    basename,             & ! [IN]
                    varname,              & ! [IN]
                    step,                 & ! [IN]
                    FILE_HISTORY_myrank,  & ! [IN]
                    allow_missing_,       & ! [IN]
                    single_               ) ! [IN]

    return
  end subroutine FILE_HISTORY_Get_realDP_1D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Get_realSP_1D( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use scale_file, only: &
       FILE_Read
    implicit none

    real(SP),         intent(out) :: var(:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FILE_Read( var,                  & ! [OUT]
                    basename,             & ! [IN]
                    varname,              & ! [IN]
                    step,                 & ! [IN]
                    FILE_HISTORY_myrank,  & ! [IN]
                    allow_missing_,       & ! [IN]
                    single_               ) ! [IN]

    return
  end subroutine FILE_HISTORY_Get_realSP_1D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Get_realDP_2D( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use scale_file, only: &
       FILE_Read
    implicit none

    real(DP),         intent(out) :: var(:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FILE_Read( var,                  & ! [OUT]
                    basename,             & ! [IN]
                    varname,              & ! [IN]
                    step,                 & ! [IN]
                    FILE_HISTORY_myrank,  & ! [IN]
                    allow_missing_,       & ! [IN]
                    single_               ) ! [IN]

    return
  end subroutine FILE_HISTORY_Get_realDP_2D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Get_realSP_2D( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use scale_file, only: &
       FILE_Read
    implicit none

    real(SP),         intent(out) :: var(:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FILE_Read( var,                  & ! [OUT]
                    basename,             & ! [IN]
                    varname,              & ! [IN]
                    step,                 & ! [IN]
                    FILE_HISTORY_myrank,  & ! [IN]
                    allow_missing_,       & ! [IN]
                    single_               ) ! [IN]

    return
  end subroutine FILE_HISTORY_Get_realSP_2D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Get_realDP_3D( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use scale_file, only: &
       FILE_Read
    implicit none

    real(DP),         intent(out) :: var(:,:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FILE_Read( var,                  & ! [OUT]
                    basename,             & ! [IN]
                    varname,              & ! [IN]
                    step,                 & ! [IN]
                    FILE_HISTORY_myrank,  & ! [IN]
                    allow_missing_,       & ! [IN]
                    single_               ) ! [IN]

    return
  end subroutine FILE_HISTORY_Get_realDP_3D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Get_realSP_3D( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use scale_file, only: &
       FILE_Read
    implicit none

    real(SP),         intent(out) :: var(:,:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_
    logical :: single_
    !---------------------------------------------------------------------------

    allow_missing_ = .false.
    single_        = .false.

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FILE_Read( var,                  & ! [OUT]
                    basename,             & ! [IN]
                    varname,              & ! [IN]
                    step,                 & ! [IN]
                    FILE_HISTORY_myrank,  & ! [IN]
                    allow_missing_,       & ! [IN]
                    single_               ) ! [IN]

    return
  end subroutine FILE_HISTORY_Get_realSP_3D

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Output_List
    implicit none

    real(DP) :: dtsec
    integer  :: id
    !---------------------------------------------------------------------------

    if ( FILE_HISTORY_id_count /= FILE_HISTORY_req_count ) then

       write(message,'(A)') '*** [HIST] All of requested variable by the namelist HISTITEM did not find.'
       call Log('I',message)
       do id = 1, FILE_HISTORY_req_count
          write(message,'(A,A24,A,L1)') '*** NAME : ', FILE_HISTORY_req(id)%item, &
                                        ', registered? : ', FILE_HISTORY_req(id)%registered
          call Log('I',message)
       enddo
       write(message,'(2A)') '*** Please set FILE_HISTORY_ERROR_PUTMISS in the namelist PARAM_HISTORY to .false.', &
                             ' when you want to disable this check.'
       call Log('I',message)

       if ( FILE_HISTORY_ERROR_PUTMISS ) then
          write(message,'(A)') 'xxx Requested variables by the namelist HISTORY_ITEM did not find. Please see detail in log file.'
          call Log('E',message)
       endif
    endif

    call Log('I','')
    write(message,'(A)') '*** [HISTORY] Output item list '
    call Log('I',message)
    write(message,'(A,I4)') '*** Number of history item :', FILE_HISTORY_req_count
    call Log('I',message)
    write(message,'(2A)') 'ITEM                    :OUTNAME                 ', &
                          ':    size:interval[sec]:    step:timeavg?:zcoord'
    call Log('I',message)
    write(message,'(2A)') '=================================================', &
                          '================================================'
    call Log('I',message)

    do id = 1, FILE_HISTORY_id_count
       dtsec = real(FILE_HISTORY_vars(id)%dstep,kind=DP) * FILE_HISTORY_DTSEC

       write(message,'(A24,1x,A24,1x,I8,1x,F13.3,1x,I8,1x,L8,1x,A6)') FILE_HISTORY_vars(id)%item,     &
                                                                      FILE_HISTORY_vars(id)%outname,  &
                                                                      FILE_HISTORY_vars(id)%size,     &
                                                                      dtsec,                          &
                                                                      FILE_HISTORY_vars(id)%dstep,    &
                                                                      FILE_HISTORY_vars(id)%taverage, &
                                                                      FILE_HISTORY_vars(id)%zcoord
       call Log('I',message)
    enddo

    write(message,'(2A)') '=================================================', &
                          '================================================'
    call Log('I',message)
    call Log('I','')

    return
  end subroutine FILE_HISTORY_Output_List

  !-----------------------------------------------------------------------------
  subroutine FILE_HISTORY_Finalize
    use scale_file, only: &
       FILE_Detach_Buffer, &
       FILE_Close
    implicit none

    integer :: fid, prev_fid
    integer :: id
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, FILE_HISTORY_id_count
       fid = FILE_HISTORY_vars(id)%fid
       if ( fid > 0 .AND. fid /= prev_fid ) then
          call FILE_Detach_Buffer( fid ) ! Release the internal buffer previously allowed to be used by PnetCDF
          call FILE_Close( fid )
          prev_fid = fid
       endif
    enddo

    return
  end subroutine FILE_HISTORY_Finalize

end module scale_file_history



!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only:t
!End:
!
!++
