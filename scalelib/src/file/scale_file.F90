!-------------------------------------------------------------------------------
!> module file
!!
!! @par Description
!!          file I/O hundring
!!
!! @author Team SCALE
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from file/scale_file.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module scale_file
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
       Log, &
       LOG_LMSG
  use scale_precision, only: &
       DP, &
       SP
  use scale_file_h
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FILE_open
  public :: FILE_create
  public :: FILE_set_option
  public :: FILE_def_axis
  public :: FILE_put_axis
  public :: FILE_write_axis
  public :: FILE_def_associatedCoordinate
  public :: FILE_put_associatedCoordinate
  public :: FILE_write_associatedCoordinate
  public :: FILE_add_variable
  public :: FILE_def_variable
  public :: FILE_get_shape
  public :: FILE_get_commonInfo
  public :: FILE_get_dataInfo
  public :: FILE_get_all_dataInfo
  public :: FILE_read
  public :: FILE_write
  public :: FILE_get_globalAttribute
  public :: FILE_set_globalAttribute
  public :: FILE_get_attribute
  public :: FILE_set_attribute
  public :: FILE_add_associatedVariable
  public :: FILE_enddef
  public :: FILE_flush
  public :: FILE_close
  public :: FILE_close_all
  public :: FILE_make_fname
  public :: FILE_attach_buffer
  public :: FILE_detach_buffer

  interface FILE_get_commonInfo
     module procedure FILE_get_commonInfo_fid
     module procedure FILE_get_commonInfo_fname
  end interface FILE_get_commonInfo

  interface FILE_get_datainfo
     module procedure FILE_get_datainfo_fid
     module procedure FILE_get_datainfo_fname
  end interface FILE_get_datainfo

  interface FILE_get_all_datainfo
     module procedure FILE_get_all_datainfo_fid
     module procedure FILE_get_all_datainfo_fname
  end interface FILE_get_all_datainfo

  interface FILE_put_axis
     module procedure FILE_put_axis_realSP
     module procedure FILE_put_axis_realDP
  end interface FILE_put_axis
  interface FILE_write_axis
     module procedure FILE_write_axis_realSP
     module procedure FILE_write_axis_realDP
  end interface FILE_write_axis
  interface FILE_put_associatedCoordinate
    module procedure FILE_put_associatedCoordinate_realSP_1D
    module procedure FILE_put_associatedCoordinate_realDP_1D
    module procedure FILE_put_associatedCoordinate_realSP_2D
    module procedure FILE_put_associatedCoordinate_realDP_2D
    module procedure FILE_put_associatedCoordinate_realSP_3D
    module procedure FILE_put_associatedCoordinate_realDP_3D
    module procedure FILE_put_associatedCoordinate_realSP_4D
    module procedure FILE_put_associatedCoordinate_realDP_4D
  end interface FILE_put_associatedCoordinate
  interface FILE_write_associatedCoordinate
    module procedure FILE_write_associatedCoordinate_RealSP_1D
    module procedure FILE_write_associatedCoordinate_RealDP_1D
    module procedure FILE_write_associatedCoordinate_RealSP_2D
    module procedure FILE_write_associatedCoordinate_RealDP_2D
    module procedure FILE_write_associatedCoordinate_RealSP_3D
    module procedure FILE_write_associatedCoordinate_RealDP_3D
    module procedure FILE_write_associatedCoordinate_RealSP_4D
    module procedure FILE_write_associatedCoordinate_RealDP_4D
  end interface FILE_write_associatedCoordinate
  interface FILE_add_variable
     module procedure FILE_add_variable_no_time
     module procedure FILE_add_variable_realSP
     module procedure FILE_add_variable_realDP
  end interface FILE_add_variable
  interface FILE_read
    module procedure FILE_read_realSP_1D
    module procedure FILE_read_realDP_1D
    module procedure FILE_read_realSP_2D
    module procedure FILE_read_realDP_2D
    module procedure FILE_read_realSP_3D
    module procedure FILE_read_realDP_3D
    module procedure FILE_read_realSP_4D
    module procedure FILE_read_realDP_4D
    module procedure FILE_read_var_realSP_1D
    module procedure FILE_read_var_realDP_1D
    module procedure FILE_read_var_realSP_2D
    module procedure FILE_read_var_realDP_2D
    module procedure FILE_read_var_realSP_3D
    module procedure FILE_read_var_realDP_3D
    module procedure FILE_read_var_realSP_4D
    module procedure FILE_read_var_realDP_4D
  end interface FILE_read
  interface FILE_write
    module procedure FILE_write_realSP_1D
    module procedure FILE_write_realDP_1D
    module procedure FILE_write_realSP_2D
    module procedure FILE_write_realDP_2D
    module procedure FILE_write_realSP_3D
    module procedure FILE_write_realDP_3D
    module procedure FILE_write_realSP_4D
    module procedure FILE_write_realDP_4D
  end interface FILE_write
  interface FILE_get_globalAttribute
     module procedure FILE_get_globalAttribute_text_fid
     module procedure FILE_get_globalAttribute_int_fid
     module procedure FILE_get_globalAttribute_float_fid
     module procedure FILE_get_globalAttribute_double_fid
     module procedure FILE_get_globalAttribute_text_fname
     module procedure FILE_get_globalAttribute_int_fname
     module procedure FILE_get_globalAttribute_float_fname
     module procedure FILE_get_globalAttribute_double_fname
  end interface FILE_get_globalAttribute
  interface FILE_set_globalAttribute
     module procedure FILE_set_globalAttribute_text
     module procedure FILE_set_globalAttribute_int
     module procedure FILE_set_globalAttribute_float
     module procedure FILE_set_globalAttribute_double
  end interface FILE_set_globalAttribute
  interface FILE_get_attribute
     module procedure FILE_get_attribute_text
     module procedure FILE_get_attribute_int
     module procedure FILE_get_attribute_float
     module procedure FILE_get_attribute_double
  end interface FILE_get_attribute
  interface FILE_set_attribute
     module procedure FILE_set_attribute_text
     module procedure FILE_set_attribute_int
     module procedure FILE_set_attribute_float
     module procedure FILE_set_attribute_double
  end interface FILE_set_attribute

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  integer,                   private, parameter :: FILE_nfile_max = 512   ! number limit of file
                                                 ! Keep consistency with "FILE_MAX" in scale_netcdf.c
  integer,                   private, parameter :: FILE_nvar_max  = 40960 ! number limit of variables
                                                 ! Keep consistency with "VAR_MAX" in scale_netcdf.c

  character(len=FILE_HLONG), private,      save :: FILE_fname_list(FILE_nfile_max)
  integer,                   private,      save :: FILE_fid_list  (FILE_nfile_max)
  integer,                   private,      save :: FILE_fid_count = 1
  character(len=FILE_HLONG), private,      save :: FILE_vname_list  (FILE_nvar_max)
  integer,                   private,      save :: FILE_vid_fid_list(FILE_nvar_max)
  integer,                   private,      save :: FILE_vid_list    (FILE_nvar_max)
  integer,                   private,      save :: FILE_vid_count = 1
  integer,                   private,      save :: mpi_myrank

  character(len=LOG_LMSG),   private            :: message

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  subroutine FILE_create( &
       fid,         &
       existed,     &
       basename,    &
       title,       &
       source,      &
       institution, &
       master,      &
       myrank,      &
       single,      &
       time_units,  &
       append,      &
       comm         )
    use mpi, only: &
       MPI_COMM_NULL
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: title
    character(len=*), intent(in)  :: source
    character(len=*), intent(in)  :: institution
    integer,          intent(in)  :: master
    integer,          intent(in)  :: myrank

    logical,          intent(in), optional :: single
    character(len=*), intent(in), optional :: time_units
    logical,          intent(in), optional :: append
    integer,          intent(in), optional :: comm       ! MPI communicator

    character(len=FILE_HMID) :: time_units_
    logical :: single_
    integer :: mode

    integer :: error
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    single_ = .false.
    if ( present(single) ) then
       if( single .AND. myrank /= master ) return ! do nothing
       single_ = single
    endif

    if ( present(time_units) ) then
       time_units_ = time_units
    else
       time_units_ = 'seconds'
    endif

    mode = FILE_FWRITE
    if ( present(append) ) then
       if( append ) mode = FILE_FAPPEND
    endif

    call FILE_get_fid( fid,      & ! [OUT]
                       existed,  & ! [OUT]
                       basename, & ! [IN]
                       mode,     & ! [IN]
                       single_,  & ! [IN]
                       comm      ) ! [IN]

    if( existed ) return

    !--- append package header to the file
    call FILE_set_globalAttribute( fid, "title"      , title       ) ! [IN]
    call FILE_set_globalAttribute( fid, "source"     , source      ) ! [IN]
    call FILE_set_globalAttribute( fid, "institution", institution ) ! [IN]

    if ( .NOT. present(comm) .OR. comm == MPI_COMM_NULL ) then
       ! for shared-file parallel I/O, skip attributes related to MPI processes
       call FILE_set_globalAttribute( fid, "myrank"  , (/myrank/)  ) ! [IN]
    endif

    call file_set_tunits_c( fid,         & ! [IN]
                            time_units_, & ! [IN]
                            error        ) ! [OUT]

    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx [FILE_create] failed to set time units')
    endif

    return
  end subroutine FILE_create

  !-----------------------------------------------------------------------------
  subroutine FILE_get_var_num( &
       fid,         &
       nvars_limit, &
       nvars        )
    implicit none

    integer, intent(in)  :: fid
    integer, intent(in)  :: nvars_limit
    integer, intent(out) :: nvars

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_nvars_c( fid,         & ! (in)
                           nvars, error ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(message,*) 'xxx [FILE_get_var_num] failed to get varnum. fid = ', fid
       call Log('E', message)
    end if

    if ( nvars > nvars_limit ) then
       write(message,*) 'xxx [FILE_get_var_num] number of variables exceeds the requested size.', nvars, nvars_limit
       call Log('E', message)
    endif

    return
  end subroutine FILE_get_var_num

  !-----------------------------------------------------------------------------
  subroutine FILE_get_var_name( &
       fid,    &
       vid,    &
       varname )
    implicit none

    integer,          intent(in)  :: fid
    integer,          intent(in)  :: vid
    character(len=*), intent(out) :: varname

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_varname_c( fid, vid,      & ! (in)
                             varname, error ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(message,*) 'xxx [FILE_get_var_name] failed to get varname. vid = ', vid
       call Log('E', message)
    end if

    return
  end subroutine FILE_get_var_name

  !-----------------------------------------------------------------------------
  ! interface FILE_get_globalAttribute
  !-----------------------------------------------------------------------------
  subroutine FILE_get_globalAttribute_text_fid( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    character(len=*), intent(out) :: val

    integer :: error

    call file_get_globalattribute_text_c( & ! (in)
         fid, key,                        & ! (in)
         val, error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get text global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_get_globalAttribute_text_fid

  !-----------------------------------------------------------------------------
  subroutine FILE_get_globalAttribute_int_fid( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    integer,          intent(out) :: val(:)

    integer :: error

    call file_get_globalattribute_int_c( & ! (in)
         fid, key, size(val),            & ! (in)
         val, error                      ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get integer global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_get_globalAttribute_int_fid

  !-----------------------------------------------------------------------------
  subroutine FILE_get_globalAttribute_float_fid( &
       fid, & ! (in)
       key, & ! (in)
       val  ) ! (out)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(SP),    intent(out) :: val(:)

    integer :: error

    call file_get_globalAttribute_float_c( & ! (in)
         fid, key, size(val), & ! (in)
         val, error           ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get float global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_get_globalAttribute_float_fid

  !-----------------------------------------------------------------------------
  subroutine FILE_get_globalAttribute_double_fid( &
       fid, & ! (in)
       key, & ! (in)
       val  ) ! (out)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(DP),    intent(out) :: val(:)

    integer :: error

    call file_get_globalAttribute_double_c( & ! (in)
         fid, key, size(val), & ! (in)
         val, error           ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get double global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_get_globalAttribute_double_fid

  subroutine FILE_get_globalAttribute_text_fname( &
       basename, &
       key,      &
       myrank,   &
       val,      &
       single    )
    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: key
    integer,          intent(in) :: myrank

    character(len=*), intent(out) :: val

    logical,          intent(in), optional :: single

    integer :: fid

    call FILE_open( fid,              & ! (out)
         basename, FILE_FREAD,        & ! (in)
         myrank=myrank, single=single ) ! (in)

    call FILE_get_globalAttribute( fid, key, & ! (in)
                                   val       ) ! (out)

    return
  end subroutine FILE_get_globalAttribute_text_fname

  !-----------------------------------------------------------------------------
  subroutine FILE_get_globalAttribute_int_fname( &
       basename, &
       key,      &
       myrank,   &
       val,      &
       single    )
    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: key
    integer,          intent(in) :: myrank

    integer, intent(out) :: val(:)

    logical, intent(in), optional :: single

    integer :: fid

    call FILE_open( fid,              & ! (out)
         basename, FILE_FREAD,        & ! (in)
         myrank=myrank, single=single ) ! (in)

    call FILE_get_globalAttribute( fid, key, & ! (in)
                                   val(:)    ) ! (out)

    return
  end subroutine FILE_get_globalAttribute_int_fname

  !-----------------------------------------------------------------------------
  subroutine FILE_get_globalAttribute_float_fname( &
       basename, &
       key,      &
       myrank,   &
       val,      &
       single    )
    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: key
    integer,          intent(in) :: myrank

    real(SP), intent(out) :: val(:)

    logical, intent(in), optional :: single

    integer :: fid

    call FILE_open( fid,              & ! (out)
         basename, FILE_FREAD,        & ! (in)
         myrank=myrank, single=single ) ! (in)

    call FILE_get_globalAttribute( fid, key, & ! (in)
                                   val(:)    ) ! (out)

    return
  end subroutine FILE_get_globalAttribute_float_fname

  !-----------------------------------------------------------------------------
  subroutine FILE_get_globalAttribute_double_fname( &
       basename, &
       key,      &
       myrank,   &
       val,      &
       single    )
    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: key
    integer,          intent(in) :: myrank

    real(DP), intent(out) :: val(:)

    logical, intent(in), optional :: single

    integer :: fid

    call FILE_open( fid,              & ! (out)
         basename, FILE_FREAD,        & ! (in)
         myrank=myrank, single=single ) ! (in)

    call FILE_get_globalAttribute( fid, key, & ! (in)
                                   val(:)    ) ! (out)

    return
  end subroutine FILE_get_globalAttribute_double_fname


  !-----------------------------------------------------------------------------
  subroutine FILE_set_globalattribute_text( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_globalattribute_text_c( fid, & ! (in)
         key, val,                              & ! (in)
         error                                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set text global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_set_globalattribute_text

  !-----------------------------------------------------------------------------
  subroutine FILE_set_globalattribute_int( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: error

    call file_set_globalattribute_int_c( fid, & ! (in)
         key, val, size(val),                 & ! (in)
         error                                ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set integer global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_set_globalattribute_int

  !-----------------------------------------------------------------------------
  subroutine FILE_set_globalattribute_float( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(SP),    intent(in) :: val(:)

    integer :: error

    call file_set_globalattribute_float_c( fid, & ! (in)
         key, val, size(val), & ! (in)
         error                ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set float global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_set_globalattribute_float

  !-----------------------------------------------------------------------------
  subroutine FILE_set_globalattribute_double( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(DP),    intent(in) :: val(:)

    integer :: error

    call file_set_globalattribute_double_c( fid, & ! (in)
         key, val, size(val), & ! (in)
         error                ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set double global attribute: '//trim(key))
    end if

    return
  end subroutine FILE_set_globalattribute_double

  !-----------------------------------------------------------------------------
  subroutine FILE_add_associatedvariable( fid, vname, existed )
    integer,           intent(in)  :: fid
    character(len=*),  intent(in)  :: vname
    logical, optional, intent(out) :: existed

    integer :: error

    call file_add_associatedvariable_c( fid, vname , & ! (in)
                                        error        ) ! (out)

    if ( present(existed) ) then
       if ( error == FILE_ALREADY_EXISTED_CODE ) then
          existed = .true.
          return
       end if
       existed = .false.
    end if

    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to add associated variable: '//trim(vname))
    end if

    return
  end subroutine FILE_add_associatedvariable

  !-----------------------------------------------------------------------------
  subroutine FILE_set_option( &
       fid,      & ! (in)
       filetype, & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: filetype
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_option_c( fid, filetype, key, val, & ! (in)
                            error                    ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set option')
    end if

    return
  end subroutine FILE_set_option

  !-----------------------------------------------------------------------------
  subroutine FILE_open( &
      fid,       & ! (out)
      basename,  & ! (in)
      mode,      & ! (in)
      single,    & ! (in) optional
      comm,      & ! (in) optional
      myrank     & ! (in) optional
      )
    implicit none

    integer,          intent(out) :: fid
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: comm
    integer,          intent( in), optional :: myrank

    logical :: existed
    logical :: single_

    single_ = .false.

    if ( present(single) ) single_ = single
    if ( present(myrank) ) mpi_myrank = myrank

    call FILE_get_fid( fid, existed,   & ! (out)
         basename, mode, single_, comm ) ! (in)

    return
  end subroutine FILE_open

  !-----------------------------------------------------------------------------
  ! interface FILE_PutAxis
  !-----------------------------------------------------------------------------
  subroutine FILE_put_axis_realSP( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_axis_c( fid, name, desc, units, dim_name, dtype, val, size(val), SP, & ! (in)
         error                                                                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FILE_put_axis_realSP
  subroutine FILE_put_axis_realDP( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_axis_c( fid, name, desc, units, dim_name, dtype, val, size(val), DP, & ! (in)
         error                                                                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FILE_put_axis_realDP

  subroutine FILE_def_axis( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       dim_size  ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    integer,          intent(in) :: dim_size

    integer :: error

    call file_def_axis_c( fid, name, desc, units, dim_name, dtype, dim_size, & ! (in)
         error                                                             ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to define axis')
    end if

    return
  end subroutine FILE_def_axis

  !-----------------------------------------------------------------------------
  ! interface FILE_WriteAxis
  !-----------------------------------------------------------------------------
  subroutine FILE_write_axis_realSP( &
       fid,      & ! (in)
       name,     & ! (in)
       val,      & ! (in)
       start     ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer :: error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis_c( fid, name, val, SP, start, shape(val), & ! (in)
            error                                                          ) ! (out)
    else
       call file_write_axis_c( fid, name, val, SP, (/1/), shape(val), & ! (in)
            error                                                          ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to write axis: '//trim(name))
    end if

    return
  end subroutine FILE_write_axis_realSP
  subroutine FILE_write_axis_realDP( &
       fid,      & ! (in)
       name,     & ! (in)
       val,      & ! (in)
       start     ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer :: error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis_c( fid, name, val, DP, start, shape(val), & ! (in)
            error                                                          ) ! (out)
    else
       call file_write_axis_c( fid, name, val, DP, (/1/), shape(val), & ! (in)
            error                                                          ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to write axis: '//trim(name))
    end if

    return
  end subroutine FILE_write_axis_realDP

  !-----------------------------------------------------------------------------
  ! interface FILE_put_associatedCoordinate
  !-----------------------------------------------------------------------------
  subroutine FILE_put_associatedCoordinate_realSP_1D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_1D
  subroutine FILE_put_associatedCoordinate_realDP_1D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_1D
  subroutine FILE_put_associatedCoordinate_realSP_2D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_2D
  subroutine FILE_put_associatedCoordinate_realDP_2D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_2D
  subroutine FILE_put_associatedCoordinate_realSP_3D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_3D
  subroutine FILE_put_associatedCoordinate_realDP_3D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_3D
  subroutine FILE_put_associatedCoordinate_realSP_4D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_4D
  subroutine FILE_put_associatedCoordinate_realDP_4D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_4D

  subroutine FILE_def_associatedCoordinate( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype      ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype

    integer :: error
    intrinsic size

    call file_def_associatedcoordinate_c( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_def_associatedCoordinate

  !-----------------------------------------------------------------------------
  ! interface FILE_write_associatedCoordinate
  !-----------------------------------------------------------------------------
  subroutine FILE_write_associatedCoordinate_realSP_1D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            1, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            1, (/1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_1D
  subroutine FILE_write_associatedCoordinate_realDP_1D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            1, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            1, (/1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_1D
  subroutine FILE_write_associatedCoordinate_realSP_2D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            2, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            2, (/1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_2D
  subroutine FILE_write_associatedCoordinate_realDP_2D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            2, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            2, (/1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_2D
  subroutine FILE_write_associatedCoordinate_realSP_3D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            3, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            3, (/1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_3D
  subroutine FILE_write_associatedCoordinate_realDP_3D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            3, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            3, (/1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_3D
  subroutine FILE_write_associatedCoordinate_realSP_4D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            4, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, SP, & ! (in)
            4, (/1,1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_4D
  subroutine FILE_write_associatedCoordinate_realDP_4D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            4, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( fid, name, val, DP, & ! (in)
            4, (/1,1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinate: '//trim(name))
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_4D

  !-----------------------------------------------------------------------------
  ! interface FILE_add_variable
  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_no_time( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    logical,          intent( in), optional :: tavg

    call FILE_add_variable_realDP(vid, fid, varname, desc, units, dims, dtype, -1.0_DP, tavg )

    return
  end subroutine FILE_add_variable_no_time

  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_realSP( &
       vid,     &
       fid,     &
       varname, &
       desc,    &
       units,   &
       dims,    &
       dtype,   &
       tint,    &
       tavg     )
    implicit none

    integer,          intent(out) :: vid
    integer,          intent(in)  :: fid
    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    character(len=*), intent(in)  :: dims(:)
    integer,          intent(in)  :: dtype
    real(SP),    intent(in)  :: tint

    logical,          intent(in), optional :: tavg

    real(DP) :: tint8
    integer  :: ndims
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_vid_count
       if (       FILE_vid_fid_list(n) == fid     &
            .AND. FILE_vname_list  (n) == varname ) then
          vid = FILE_vid_list(n)
          exit
       endif
    enddo

    if ( vid < 0 ) then ! variable registration

       tint8 = real(tint,DP)
       ndims = size(dims)
       itavg = 0

       if ( present(tavg) ) then
          if( tavg ) itavg = 1
       endif

       call file_add_variable_c( vid,                                                         & ! [OUT]
                                 fid, varname, desc, units, dims, ndims, dtype, tint8, itavg, & ! [IN]
                                 error                                                        ) ! [OUT]

       if ( error /= FILE_SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       endif

       FILE_vname_list  (FILE_vid_count) = trim(varname)
       FILE_vid_list    (FILE_vid_count) = vid
       FILE_vid_fid_list(FILE_vid_count) = fid
       FILE_vid_count                    = FILE_vid_count + 1

       write(message,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE_ variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
       call Log("I",message)
    endif

    return
  end subroutine FILE_add_variable_realSP

  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_realDP( &
       vid,     &
       fid,     &
       varname, &
       desc,    &
       units,   &
       dims,    &
       dtype,   &
       tint,    &
       tavg     )
    implicit none

    integer,          intent(out) :: vid
    integer,          intent(in)  :: fid
    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    character(len=*), intent(in)  :: dims(:)
    integer,          intent(in)  :: dtype
    real(DP),    intent(in)  :: tint

    logical,          intent(in), optional :: tavg

    real(DP) :: tint8
    integer  :: ndims
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_vid_count
       if (       FILE_vid_fid_list(n) == fid     &
            .AND. FILE_vname_list  (n) == varname ) then
          vid = FILE_vid_list(n)
          exit
       endif
    enddo

    if ( vid < 0 ) then ! variable registration

       tint8 = real(tint,DP)
       ndims = size(dims)
       itavg = 0

       if ( present(tavg) ) then
          if( tavg ) itavg = 1
       endif

       call file_add_variable_c( vid,                                                         & ! [OUT]
                                 fid, varname, desc, units, dims, ndims, dtype, tint8, itavg, & ! [IN]
                                 error                                                        ) ! [OUT]

       if ( error /= FILE_SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       endif

       FILE_vname_list  (FILE_vid_count) = trim(varname)
       FILE_vid_list    (FILE_vid_count) = vid
       FILE_vid_fid_list(FILE_vid_count) = fid
       FILE_vid_count                    = FILE_vid_count + 1

       write(message,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE_ variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
       call Log("I",message)
    endif

    return
  end subroutine FILE_add_variable_realDP

  subroutine FILE_def_variable( &
       fid,     & ! (in)
       vid,     & ! (out)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       ndims,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in) optional
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: ndims
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(DP),         intent( in), optional :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint_
    integer  :: itavg
    integer  :: error
    integer  :: n

    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_vid_count
       if ( FILE_vid_fid_list(n) == fid .and. &
            varname == FILE_vname_list(n) ) then
          vid = FILE_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration

       if ( present(tint) ) then
          tint_ = tint
       else
          tint_ = -1.0_DP
       endif

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable_c( vid,                      & ! (out)
            fid, varname, desc, units, dims, ndims, dtype, & ! (in)
            tint_, itavg,                                  & ! (in)
            error                                          ) ! (out)
       if ( error /= FILE_SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       FILE_vname_list  (FILE_vid_count) = trim(varname)
       FILE_vid_list    (FILE_vid_count) = vid
       FILE_vid_fid_list(FILE_vid_count) = fid
       FILE_vid_count                    = FILE_vid_count + 1

       write(message,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE_ variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
       call Log("I",message)
    endif

    return
  end subroutine FILE_def_variable

  !-----------------------------------------------------------------------------
  ! FILE_GetAttribute
  !-----------------------------------------------------------------------------
  subroutine FILE_get_attribute_text( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    character(len=*), intent(out) :: val

    integer :: error

    call file_get_attribute_text_c( &
         fid, vname, & ! (in)
         key,        & ! (in)
         val, error  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get text attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_get_attribute_text

  !-----------------------------------------------------------------------------
  subroutine FILE_get_attribute_int( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    integer,          intent(out) :: val(:)

    integer :: error

    intrinsic size

    call file_get_attribute_int_c( &
         fid, vname,     & ! (in)
         key, size(val), & ! (in)
         val, error      ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get integer attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_get_attribute_int
  !-----------------------------------------------------------------------------

  subroutine FILE_get_attribute_float( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    real(SP),    intent(out) :: val(:)

    integer :: error

    intrinsic size

    call file_get_attribute_float_c( &
         fid, vname,     & ! (in)
         key, size(val), & ! (in)
         val, error      ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get float attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_get_attribute_float
  subroutine FILE_get_attribute_double( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    real(DP),    intent(out) :: val(:)

    integer :: error

    intrinsic size

    call file_get_attribute_double_c( &
         fid, vname,     & ! (in)
         key, size(val), & ! (in)
         val, error      ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get double attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_get_attribute_double

  !-----------------------------------------------------------------------------
  ! FILE_set_attribute
  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_text( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_attribute_text_c( &
         fid, vname, & ! (in)
         key, val,   & ! (in)
         error       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set text attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_set_attribute_text

  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_int( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_int_c( &
         fid, vname,                & ! (in)
         key, val(:), size(val(:)), & ! (in)
         error                      ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set integer attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_set_attribute_int

  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_float( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    real(SP),    intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_float_c( &
         fid, vname,                & ! (in)
         key, val(:), size(val(:)), & ! (in)
         error                      ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set float attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_set_attribute_float
  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_double( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    real(DP),    intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_double_c( &
         fid, vname,                & ! (in)
         key, val(:), size(val(:)), & ! (in)
         error                      ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set double attribute for '//trim(vname)//': '//trim(key))
    end if

    return
  end subroutine FILE_set_attribute_double
  !-----------------------------------------------------------------------------
  ! FILE_get_shape
  !-----------------------------------------------------------------------------
  subroutine FILE_get_shape( &
      dims,          & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      myrank,        & ! (in)
      single,        & ! (in) optional
      error          ) ! (out) optional
    implicit none

    integer,          intent(out)           :: dims(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: single
    logical,          intent(out), optional :: error

    integer :: fid
    type(datainfo) :: dinfo
    integer :: ierror
    integer :: n

    logical :: single_
    logical :: suppress

    intrinsic size
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    end if

    if ( present(error) ) then
       suppress = .true.
    else
       suppress = .false.
    end if

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo, & ! (out)
         fid, varname, 1, suppress,  & ! (in)
         ierror                      ) ! (out)

    !--- verify
    if ( ierror /= FILE_SUCCESS_CODE ) then
       if ( present(error) ) then
          error = .true.
          return
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= size(dims) ) then
       write(message,*) 'xxx rank is different, ', size(dims), dinfo%rank
       call Log('E', message)
    end if
    do n = 1, size(dims)
       dims(n) = dinfo%dim_size(n)
    end do

    if ( present(error) ) error = .false.

    return
  end subroutine FILE_get_shape

  !-----------------------------------------------------------------------------
  ! FILE_get_commonInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_commonInfo_fname( &
       basename,    &
       myrank,      &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       nvars,       &
       varname      )
    implicit none

    character(len=*),           intent(in)  :: basename
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: nvars_limit
    character(len=FILE_HMID),   intent(out) :: title                ! title of the file
    character(len=FILE_HMID),   intent(out) :: source               ! for file header
    character(len=FILE_HMID),   intent(out) :: institution          ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=FILE_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: fid
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    call FILE_open( fid,       & ! [OUT]
                    basename,  & ! [IN]
                    FILE_FREAD ) ! [IN]

    call FILE_get_commonInfo_fid( fid,         & ! [IN]
                                  myrank,      & ! [IN]
                                  nvars_limit, & ! [IN]
                                  title,       & ! [OUT]
                                  source,      & ! [OUT]
                                  institution, & ! [OUT]
                                  nvars,       & ! [OUT]
                                  varname(:)   ) ! [OUT]

    return
  end subroutine FILE_get_commonInfo_fname

  subroutine FILE_get_commonInfo_fid( &
       fid,         &
       myrank,      &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       nvars,       &
       varname      )
    implicit none

    integer,                    intent(in)  :: fid
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: nvars_limit
    character(len=FILE_HMID),   intent(out) :: title                ! title of the file
    character(len=FILE_HMID),   intent(out) :: source               ! for file header
    character(len=FILE_HMID),   intent(out) :: institution          ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=FILE_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: myrank_check(1)
    integer :: v
    !---------------------------------------------------------------------------

    call FILE_get_globalAttribute( fid, 'title',       title       )
    call FILE_get_globalAttribute( fid, 'source',      source      )
    call FILE_get_globalAttribute( fid, 'institution', institution )
    call FILE_get_globalAttribute( fid, 'myrank',      myrank_check(:) )

    if ( myrank /= myrank_check(1) ) then
       call Log('E','xxx [FILE_GetCommoninfo] requested rank number is inconsistent with that in the file.')
    endif

    call FILE_get_var_num( fid, nvars_limit, nvars )

    do v = 1, nvars
       call FILE_get_var_name( fid, v, varname(v) )
    enddo

    return
  end subroutine FILE_get_commonInfo_fid

  !-----------------------------------------------------------------------------
  ! FILE_get_dataInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_dataInfo_fname( &
       basename,    &
       varname,     &
       myrank,      &
       istep,       &
       single,      &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: istep

    logical,                    intent(in),  optional :: single
    character(len=FILE_HMID),   intent(out), optional :: description
    character(len=FILE_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=FILE_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=FILE_HMID),   intent(out), optional :: time_units

    logical :: single_
    integer :: fid
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FILE_open( fid,        & ! [OUT]
                    basename,   & ! [IN]
                    FILE_FREAD, & ! [IN]
                    single_     ) ! [IN]

    call FILE_get_dataInfo_fid( fid,         & ! [IN]
                                varname,     & ! [IN]
                                istep,       & ! [IN]
                                description, & ! [OUT], optional
                                units,       & ! [OUT], optional
                                datatype,    & ! [OUT], optional
                                dim_rank,    & ! [OUT], optional
                                dim_name,    & ! [OUT], optional
                                dim_size,    & ! [OUT], optional
                                time_start,  & ! [OUT], optional
                                time_end,    & ! [OUT], optional
                                time_units   ) ! [OUT], optional

    return
  end subroutine FILE_get_dataInfo_fname

  subroutine FILE_get_dataInfo_fid( &
       fid,         &
       varname,     &
       istep,       &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: istep

    character(len=FILE_HMID),   intent(out), optional :: description
    character(len=FILE_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=FILE_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=FILE_HMID),   intent(out), optional :: time_units

    type(datainfo) :: dinfo

    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    intrinsic size
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,   & ! [OUT]
                              fid,     & ! [IN]
                              varname, & ! [IN]
                              istep,   & ! [IN]
                              .false., & ! [IN]
                              error    ) ! [OUT]

    !--- verify and exit
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx data info not found')
    endif

    if( present(description) ) description = dinfo%description
    if( present(units)       ) units       = dinfo%units
    if( present(datatype)    ) datatype    = dinfo%datatype
    if( present(dim_rank)    ) dim_rank    = dinfo%rank

    if ( present(dim_name) ) then
       ndim = min( dinfo%rank, size(dim_name) ) ! limit dimension rank
       do idim = 1, ndim
          dim_name(idim) = dinfo%dim_name(idim)
       enddo
    endif

    if ( present(dim_size) ) then
       ndim = min( dinfo%rank, size(dim_size) ) ! limit dimension rank
       do idim = 1, ndim
          dim_size(idim) = dinfo%dim_size(idim)
       enddo
    endif

    if ( present(time_units)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_globalAttribute( fid, "time_units", time_units )
       else
          time_units = dinfo%time_units
       endif
    endif

    if ( present(time_start)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_globalAttribute( fid, "time_start", time )
          time_start = time(1)
       else
          time_start = dinfo%time_start
       endif
    endif

    if ( present(time_end)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_globalAttribute( fid, "time_start", time )
          time_end = time(1)
       else
          time_end = dinfo%time_end
       end if
    endif

    return
  end subroutine FILE_get_dataInfo_fid

  !-----------------------------------------------------------------------------
  ! FILE_get_data_all_dataInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_all_dataInfo_fname( &
       step_limit,  &
       dim_limit,   &
       basename,    &
       varname,     &
       myrank,      &
       step_nmax,   &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units,  &
       single       )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(out) :: step_nmax
    character(len=FILE_HMID),   intent(out) :: description
    character(len=FILE_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=FILE_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=FILE_HMID),   intent(out) :: time_units

    logical,                    intent(in), optional :: single

    integer :: fid
    logical :: single_
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FILE_open( fid,        & ! [OUT]
                    basename,   & ! [IN]
                    FILE_FREAD, & ! [IN]
                    single_     ) ! [IN]

    call FILE_get_all_datainfo_fid( step_limit,  & ! [IN]
                                    dim_limit,   & ! [IN]
                                    fid,         & ! [IN]
                                    varname,     & ! [IN]
                                    step_nmax,   & ! [OUT]
                                    description, & ! [OUT]
                                    units,       & ! [OUT]
                                    datatype,    & ! [OUT]
                                    dim_rank,    & ! [OUT]
                                    dim_name,    & ! [OUT]
                                    dim_size,    & ! [OUT]
                                    time_start,  & ! [OUT]
                                    time_end,    & ! [OUT]
                                    time_units   ) ! [OUT]

    return
  end subroutine FILE_get_all_dataInfo_fname

  subroutine FILE_get_all_dataInfo_fid( &
       step_limit,  &
       dim_limit,   &
       fid,         &
       varname,     &
       step_nmax,   &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(out) :: step_nmax
    character(len=FILE_HMID),   intent(out) :: description
    character(len=FILE_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=FILE_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=FILE_HMID),   intent(out) :: time_units

    type(datainfo) :: dinfo

    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    integer  :: istep
    !---------------------------------------------------------------------------

    ! initialize
    description   = ""
    units         = ""
    datatype      = -1
    dim_rank      = -1
    dim_name  (:) = ""
    dim_size  (:) = -1
    time_start(:) = FILE_RMISS
    time_end  (:) = FILE_RMISS

    do istep = 1, step_limit
       !--- get data information
       call file_get_datainfo_c( dinfo,   & ! [OUT]
                                 fid,     & ! [IN]
                                 varname, & ! [IN]
                                 istep,   & ! [IN]
                                 .true.,  & ! [IN]
                                 error    ) ! [OUT]

       !--- verify and exit
       if ( error /= FILE_SUCCESS_CODE ) then
          step_nmax = istep - 1
          exit
       endif

       if ( istep == 1 ) then
          description = dinfo%description
          units       = dinfo%units
          datatype    = dinfo%datatype
          dim_rank    = dinfo%rank

          ndim = min( dinfo%rank, dim_limit ) ! limit dimension rank
          do idim = 1, ndim
             dim_name(idim) = dinfo%dim_name(idim)
             dim_size(idim) = dinfo%dim_size(idim)
          enddo

          if ( dinfo%time_units == "" ) then
             call FILE_get_globalAttribute( fid, "time_units", time_units )
             call FILE_get_globalAttribute( fid, "time_start", time )
             time_start(1) = time(1)
             time_end  (1) = time(1)
             step_nmax = 1
             exit
          else
             time_units    = dinfo%time_units
             time_start(1) = dinfo%time_start
             time_end  (1) = dinfo%time_end
          endif
       else
          time_start(istep) = dinfo%time_start
          time_end  (istep) = dinfo%time_end
       endif
    enddo

    return
  end subroutine FILE_get_all_dataInfo_fid

  !-----------------------------------------------------------------------------
  ! interface FILE_read
  !-----------------------------------------------------------------------------
  subroutine FILE_read_realSP_1D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 1
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realSP_1D
  subroutine FILE_read_realDP_1D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 1
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realDP_1D
  subroutine FILE_read_realSP_2D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 2
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:,:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realSP_2D
  subroutine FILE_read_realDP_2D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 2
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:,:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realDP_2D
  subroutine FILE_read_realSP_3D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 3
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:,:,:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realSP_3D
  subroutine FILE_read_realDP_3D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 3
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:,:,:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realDP_3D
  subroutine FILE_read_realSP_4D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:,:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 4
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:,:,:,:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realSP_4D
  subroutine FILE_read_realDP_4D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:,:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                & ! (out)
         basename, FILE_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 4
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data_c( var(:,:,:,:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                            ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_realDP_4D

  subroutine FILE_read_var_realSP_1D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 1
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:), & ! (out)
            dinfo, SP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realSP_1D
  subroutine FILE_read_var_realDP_1D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 1
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:), & ! (out)
            dinfo, DP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realDP_1D
  subroutine FILE_read_var_realSP_2D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:,:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 2
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:,:), & ! (out)
            dinfo, SP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realSP_2D
  subroutine FILE_read_var_realDP_2D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:,:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 2
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:,:), & ! (out)
            dinfo, DP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realDP_2D
  subroutine FILE_read_var_realSP_3D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:,:,:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 3
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:,:,:), & ! (out)
            dinfo, SP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realSP_3D
  subroutine FILE_read_var_realDP_3D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:,:,:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 3
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:,:,:), & ! (out)
            dinfo, DP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realDP_3D
  subroutine FILE_read_var_realSP_4D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:,:,:,:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 4
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:,:,:,:), & ! (out)
            dinfo, SP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realSP_4D
  subroutine FILE_read_var_realDP_4D( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,  & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[FILE_] Value is set to 0.')
             var(:,:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par_c( var(:,:,:,:),                  & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, 4
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call Log('E', message)
          end if
       end do
       call file_read_data_c( var(:,:,:,:), & ! (out)
            dinfo, DP,                  & ! (in)
            error                            ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FILE_read_var_realDP_4D

  !-----------------------------------------------------------------------------
  ! interface FILE_write
  !-----------------------------------------------------------------------------
  subroutine FILE_write_realSP_1D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(1)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:), ts, te, SP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:), ts, te, SP, & ! (in)
            1, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realSP_1D
  subroutine FILE_write_realDP_1D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(1)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:), ts, te, DP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:), ts, te, DP, & ! (in)
            1, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realDP_1D
  subroutine FILE_write_realSP_2D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(2)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:,:), ts, te, SP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:,:), ts, te, SP, & ! (in)
            2, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realSP_2D
  subroutine FILE_write_realDP_2D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(2)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:,:), ts, te, DP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:,:), ts, te, DP, & ! (in)
            2, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realDP_2D
  subroutine FILE_write_realSP_3D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(3)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:,:,:), ts, te, SP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:,:,:), ts, te, SP, & ! (in)
            3, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realSP_3D
  subroutine FILE_write_realDP_3D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(3)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:,:,:), ts, te, DP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:,:,:), ts, te, DP, & ! (in)
            3, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realDP_3D
  subroutine FILE_write_realSP_4D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(4)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:,:,:,:), ts, te, SP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:,:,:,:), ts, te, SP, & ! (in)
            4, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realSP_4D
  subroutine FILE_write_realDP_4D( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(4)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data_c( fid, vid, var(:,:,:,:), ts, te, DP, & ! (in)
            ndims, start, count,                                         & ! (in)
            error                                                        ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( fid, vid, var(:,:,:,:), ts, te, DP, & ! (in)
            4, start_, shape(var),                                  & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_vid_count
          if ( FILE_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(FILE_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FILE_write_realDP_4D

  !-----------------------------------------------------------------------------
  ! exit netCDF define mode and enter data mode
  subroutine FILE_enddef( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, FILE_fid_count-1
       if ( FILE_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. FILE_fid_list(n) ) then
       write(message,*) 'xxx in FILE_EndDef invalid fid' , fid
       call Log('E', message)
    end if

    call file_enddef_c( fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### FILE_ end define mode       : No.', FILE_fid_list(n), ', name = ', trim(FILE_fname_list(n))
       call Log("I",message)

    else

       call Log('E', 'xxx failed to exit define mode')

    end if

    return
  end subroutine FILE_enddef

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_attach_buffer( &
       fid,       & ! (in)
       buf_amount ) ! (in)
    implicit none

    integer, intent(in) :: fid
    integer, intent(in) :: buf_amount

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, FILE_fid_count-1
       if ( FILE_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. FILE_fid_list(n) ) then
       write(message,*) 'xxx in FILE_AttachBuffer invalid fid' , fid
       call Log('E', message)
    end if

    call file_attach_buffer_c( fid, buf_amount, error )

    if ( error == FILE_SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,3A,I10)') &
       '###### FILE_ attach buffer         : No.', FILE_fid_list(n), ', name = ', trim(FILE_fname_list(n)), &
                                                                    ', size = ', buf_amount
       call Log("I",message)

    else

       call Log('E', 'xxx failed to attach buffer in PnetCDF')

    end if

    return
  end subroutine FILE_attach_buffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_detach_buffer( &
       fid        ) ! (in)
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, FILE_fid_count-1
       if ( FILE_fid_list(n) == fid ) exit
    end do
    if ( n == FILE_fid_count ) return  ! already closed

    if ( fid .NE. FILE_fid_list(n) ) then
       write(message,*) 'xxx in FILE_DetachBuffer invalid fid' , fid
       call Log('E', message)
    end if

    call file_detach_buffer_c( fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### FILE_ detach buffer         : No.', FILE_fid_list(n), ', name = ', trim(FILE_fname_list(n))
       call Log("I",message)

    else

       call Log('E', 'xxx failed to detach buffer in PnetCDF')

    end if

    return
  end subroutine FILE_detach_buffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_flush( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return
    if ( FILE_fid_count == 1 ) return

    do n = 1, FILE_fid_count-1
       if ( FILE_fid_list(n) == fid ) exit
    end do
    if ( n == FILE_fid_count ) return  ! already closed

    if ( fid .NE. FILE_fid_list(n) ) then
       write(message,*) 'xxx in FILE_Flush invalid fid' , fid
       call Log('E', message)
    end if

    call file_flush_c( fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### FILE_ flush                 : No.', FILE_fid_list(n), ', name = ', trim(FILE_fname_list(n))
       call Log("I",message)

    else

       call Log('E', 'xxx failed to flush PnetCDF pending requests')

    end if

    return
  end subroutine FILE_flush

  !-----------------------------------------------------------------------------
  subroutine FILE_close( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    character(len=FILE_HLONG) :: fname
    integer                   :: error
    integer                   :: n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, FILE_fid_count-1
       if ( FILE_fid_list(n) == fid ) exit
    end do
    if ( n == FILE_fid_count ) return  ! already closed

    if ( fid /= FILE_fid_list(n) ) then
       write(message,*) 'xxx in FILE_Close invalid fid ', fid
       call Log('E', message)
    end if

    call file_close_c( fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') &
       '###### FILE_ close                 : No.', FILE_fid_list(n), ', name = ', trim(FILE_fname_list(n))
       call Log("I",message)

    elseif( error /= FILE_ALREADY_CLOSED_CODE ) then

       call Log('E', 'xxx failed to close file')

    end if

    do n = 1, FILE_fid_count-1
       if ( FILE_fid_list(n) == fid ) then
          FILE_fid_list(n) = -1
          FILE_fname_list(n) = ''
       end if
    end do

    return
  end subroutine FILE_close
  !-----------------------------------------------------------------------------
  subroutine FILE_close_all
    implicit none

    integer n
    !---------------------------------------------------------------------------

    do n = 1, FILE_fid_count-1
       call FILE_close( FILE_fid_list(n) )
    enddo

    return
  end subroutine FILE_close_all

  !-----------------------------------------------------------------------------
  ! private
  !-----------------------------------------------------------------------------
  subroutine FILE_make_fname( &
       fname,    & ! (out)
       basename, & ! (in)
       prefix,   & ! (in)
       myrank,   & ! (in)
       len       ) ! (in)
    character(len=*), intent(out) :: fname
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: prefix
    integer,          intent( in) :: myrank
    integer,          intent( in) :: len

    !                           12345678901234567
    character(len=17) :: fmt = "(A, '.', A, I*.*)"
    !---------------------------------------------------------------------------

    if ( len < 1 .or. len > 9 ) then
       call Log('E', 'xxx len is invalid')
    end if

    write(fmt(14:14),'(I1)') len
    write(fmt(16:16),'(I1)') len
    write(fname, fmt) trim(basename), trim(prefix), myrank

    return
  end subroutine FILE_make_fname
  !-----------------------------------------------------------------------------
  subroutine FILE_get_fid( &
      fid,        &
      existed,    &
      basename,   &
      mode,       &
      single,     &
      comm        )
    use MPI, only : MPI_COMM_NULL, MPI_COMM_SELF
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in) :: single
    integer,          intent( in), optional :: comm

    character(len=FILE_HSHORT) :: rwname(0:2)
    data rwname / 'READ','WRITE','APPEND' /

    character(len=FILE_HLONG) :: fname
    integer                   :: n

    integer :: error
    integer :: comm_
    !---------------------------------------------------------------------------

    !--- register new file and open
    comm_ = MPI_COMM_NULL
    if ( present(comm) ) comm_ = comm
    if ( comm_ .NE. MPI_COMM_NULL ) then
       ! parallel I/O on a single shared netCDF file
       fname = basename
       comm_ = comm
    elseif ( single ) then
       fname = trim(basename)//'.peall'
    else
       call FILE_make_fname(fname,trim(basename),'pe',mpi_myrank,6)
    endif

    !--- search existing file
    fid = -1
    do n = 1, FILE_fid_count-1
       if ( fname==FILE_fname_list(n) ) fid = FILE_fid_list(n)
    enddo

    if ( fid >= 0 ) then
       existed = .true.
       return
    end if

    call file_open_c( fid,   & ! (out)
         fname, mode, comm_, & ! (in)
         error               ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       call Log('E', 'xxx failed to open file :'//trim(fname)//'.nc')
    end if

    call Log("I",'')
    write(message,'(A,A6,A,I3.3,2A)') &
    '###### FILE_ registration (', trim(rwname(mode)), ') : No.', fid, ', name = ', trim(fname)
    call Log("I",message)

    FILE_fname_list(FILE_fid_count) = trim(fname)
    FILE_fid_list  (FILE_fid_count) = fid
    FILE_fid_count                  = FILE_fid_count + 1

    existed = .false.

    return
  end subroutine FILE_get_fid

end module scale_file
!-------------------------------------------------------------------------------


!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only: t
!End:
!
!++
